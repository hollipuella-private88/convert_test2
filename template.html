<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>{{TITLE}}</title>
<meta name="trpg-key" content="{{KEY}}">
<style>
:root{
  --bg:#fff; --text:#333; --line:#e5e5e5; --accent:#e7f1ff; --accent2:#b9d6ff;
  --header:56px; --tabs:52px; --drawerW:min(92vw,420px); --r:12px; --sh:0 6px 20px rgba(0,0,0,.08);
  --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);font:16px/1.85 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Yu Gothic UI","Meiryo",sans-serif}

/* header */
header{position:sticky;inset-block-start:0;z-index:60;height:var(--header);display:grid;grid-template-columns:auto 1fr auto;place-items:center;padding:8px;border-block-end:1px solid var(--line);background:#fff}
.title{text-align:center;font-weight:700}
.icon{min-inline-size:44px;min-block-size:40px;border:1px solid var(--line);border-radius:10px;background:#fff;display:inline-grid;place-items:center;cursor:pointer;padding:0 .9em}
.icon:focus-visible{outline:2px solid #2563eb;outline-offset:2px}

/* main and tabs */
main{block-size:calc(100dvh - var(--header) - var(--tabs));overflow:auto;scroll-behavior:smooth;padding:16px min(6vw,28px) 120px}
nav.tabs{position:sticky;inset-block-end:0;block-size:var(--tabs);display:grid;grid-template-columns:repeat(3,1fr);border-block-start:1px solid var(--line);background:#fff;z-index:50}
.tab{appearance:none;border:0;background:#fff;cursor:pointer;padding:.6em 0}
.tab[aria-current="page"]{background:var(--accent);font-weight:700}
.page{display:none}
.page[aria-hidden="false"]{display:block}

/* drawers */
.drawer{position:fixed;inset-block-start:var(--header);inset-block-end:0;inline-size:var(--drawerW);background:#fff;border:1px solid var(--line);box-shadow:var(--sh);overflow:auto;transition:.25s;z-index:900}
.drawer.left{inset-inline-start:0;transform:translateX(-110%)}
.drawer.right{inset-inline-end:0;transform:translateX(110%)}
.drawer.open{transform:translateX(0)}

/* TOC/Tool drawer content */
.toc{display:grid;grid-template-columns:120px 1fr;gap:8px;padding:8px}
.toc .pages{border-inline-end:1px solid var(--line);padding-inline-end:8px;display:flex;flex-direction:column;gap:6px}
.toc .pages button{inline-size:100%;margin:0;border:1px solid var(--line);border-radius:8px;background:#fff;padding:6px;cursor:pointer;text-align:center}
.toc .pages button[aria-current="page"]{background:var(--accent);border-color:var(--accent2);font-weight:700}
.toc .area{padding-inline:4px}

/* TOC-like rows (used for both TOC and Tool) */
.toc .row{display:grid;grid-template-columns:24px 1fr;gap:6px;border-block-end:1px dashed #eee;padding:8px 4px}
.toc .tw{cursor:pointer;color:#666}.toc .tw.off{opacity:.25;pointer-events:none}
.lvl2{padding-inline-start:16px}.lvl3{padding-inline-start:32px}

/* search */
.searchbar{display:flex;gap:8px;padding:8px}
.searchbar input{flex:1;border:1px solid var(--line);border-radius:999px;padding:.6em .9em}
.chips{display:flex;gap:6px;flex-wrap:wrap;padding:0 8px 8px}
.chip{border:1px solid var(--line);border-radius:999px;padding:.2em .6em;background:#fff;cursor:pointer}
.chip.on{background:var(--accent);border-color:var(--accent2);font-weight:700}

/* card */
.card{border:1px solid var(--line);border-radius:10px;padding:8px;margin:8px;background:#fff}
.card .meta{display:flex;justify-content:space-between;gap:8px;font-size:12px;color:#666}
.card .title{font-weight:700;margin:.2em 0}
.card .fulltext{
  display:-webkit-box;
  -webkit-line-clamp:1;
  -webkit-box-orient:vertical;
  overflow:hidden;
  text-overflow:ellipsis;
}
.card.open .fulltext{display:block;-webkit-line-clamp:unset;overflow:visible}
.card .fulltext .note{background:#e7f1ff;border-radius:3px;padding:.05em .15em}

/* headings & code */
h1,h2,h3{scroll-margin-top:calc(var(--header) + 10px)}
h1{text-align:center;font-size:1.6rem;font-weight:800;border-block-end:1px solid var(--line);padding-block-end:.4em;margin:1.2em 0 .8em}
h2{font-size:1.25rem;font-weight:700;margin:1.3em 0 .2em}
h3{font-size:1.05rem;font-weight:700;margin:1.1em 0 .2em;padding-inline-start:8px;border-inline-start:3px solid var(--accent2)}

/* code wrap */
pre.code{position:relative;background:#f5f6f7;border:1px solid var(--line);border-radius:10px;padding:14px 12px 12px;white-space:pre-wrap;overflow-wrap:anywhere;word-break:break-word}
pre.code code{white-space:inherit}
pre.code .copy{position:absolute;inset:8px 8px auto auto;border:1px solid var(--line);border-radius:999px;background:#fff;padding:.2em .6em;cursor:pointer;font:12px/1 var(--mono)}
pre.code .copy.done{background:#e1f6e7;border-color:#b9ebc9}

/* memo */
.note{background:#e7f1ff;border-radius:3px;padding:.05em .15em}
.fab{position:fixed;z-index:950;display:none;min-inline-size:40px;min-block-size:40px;border:1px solid var(--line);border-radius:999px;background:#fff;box-shadow:var(--sh);place-items:center;cursor:pointer}
.fab.show{display:grid}
.backdrop{position:fixed;inset:0;background:rgba(0,0,0,.15);z-index:995}
.pop{position:fixed;z-index:1000;background:#fff;border:1px solid var(--line);border-radius:10px;box-shadow:var(--sh);padding:10px;min-inline-size:min(92vw,320px);max-inline-size:min(96vw,420px);max-block-size:80dvh;overflow:auto}
.pop h4{margin:.2em 0 .6em}
.pop textarea{inline-size:100%;min-block-size:110px;border:1px solid var(--line);border-radius:8px;padding:8px;font:13px/1.6 var(--mono)}
.actions{display:flex;gap:10px;justify-content:space-between;margin-top:8px;flex-wrap:wrap}
.btn{border:1px solid var(--line);border-radius:8px;background:#fff;padding:.5em .9em;white-space:nowrap;min-inline-size:86px}
.btn.primary{background:#0d6efd;border-color:#0d6efd;color:#fff}
.btn.danger{color:#b00}
mark.hl{background:#fff3a0}

/* tool: 変換語 見出しの下線 & 入力欄の角丸 */
.tool-word{border-bottom:1px solid var(--line);padding-bottom:4px}
.input-box{width:100%;border:1px solid var(--line);border-radius:8px;padding:.5em .7em;margin:6px 0 12px;background:#fff}

/* --- card preview spacing fix --- */
.card .fulltext > :first-child{ margin-block-start:0 !important; }
.card .fulltext > :last-child { margin-block-end:0 !important; }
.card .fulltext > p,
.card .fulltext > ul,
.card .fulltext > ol,
.card .fulltext > pre,
.card .fulltext > blockquote { margin-block:.35em .4em; }

@media(max-width:768px){.toc{grid-template-columns:98px 1fr}}
</style>
</head>
<body>
<header>
  <button id="btnToc" class="icon" aria-label="目次">≡</button>
  <div class="title">{{TITLE}}</div>
  <button id="btnSearch" class="icon" aria-label="検索">◀</button>
</header>

<main id="sc">
  <section class="page" data-page="info" aria-hidden="false"><!-- CONTENT:info --></section>
  <section class="page" data-page="main" aria-hidden="true"><!-- CONTENT:main --></section>
  <section class="page" data-page="etc"  aria-hidden="true"><!-- CONTENT:etc --></section>
</main>

<nav class="tabs" role="tablist" aria-label="ページ切替">
  <button class="tab" data-target="info" aria-current="page">info</button>
  <button class="tab" data-target="main">main</button>
  <button class="tab" data-target="etc">etc</button>
</nav>

<!-- left drawer: TOC + tool -->
<aside id="toc" class="drawer left" aria-label="目次/ツール">
  <div class="toc">
    <div class="pages" id="tocPages"></div>
    <div class="area" id="tocArea"><!-- TOC tree or Tool --></div>
  </div>
</aside>

<!-- right drawer: search -->
<aside id="sea" class="drawer right" aria-label="検索">
  <div class="searchbar"><input id="q" placeholder="空白区切り AND（全ページ）"></div>
  <div id="chips" class="chips"></div>
  <div id="res" aria-live="polite"></div>
</aside>

<button id="fab" class="fab" title="メモを追加">＋</button>

<!-- 変換器が埋める想定の JSON -->
<script id="convert-words" type="application/json">{"words":[]}</script>

<script>
(()=>{"use strict";
/* ===== util & state ===== */
const $=(s,r=document)=>r.querySelector(s), $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const sc=$("#sc"), pages=$$(".page"), tabs=$$(".tab"), toc=$("#toc"), sea=$("#sea"), btnT=$("#btnToc"), btnS=$("#btnSearch");
const MOBILE=()=>matchMedia("(max-width:768px)").matches;
const vp=()=>{const x=visualViewport;return x?{x:x.offsetLeft,y:x.offsetTop,w:x.width,h:x.height}:{x:0,y:0,w:innerWidth,h:innerHeight};};
const pageOrder=new Map([["info",0],["main",1],["etc",2]]);
const cmp=(a,b)=> (pageOrder.get(a.page)-pageOrder.get(b.page)) || ((a.order??9e8)-(b.order??9e8));
const parseHash=h=>{const raw=decodeURIComponent(h.replace(/^#/,""));if(!raw)return{id:"",page:null};const m=raw.match(/^([A-Za-z0-9_-]+):(.*)$/);return m?{page:m[1],id:m[2]}:{page:null,id:raw}};
const FIXED_KEY=(document.querySelector('meta[name="trpg-key"]')?.content||"").trim();
if(!/^[A-Za-z0-9_-]+$/.test(FIXED_KEY)) alert("テンプレートの固定キー(meta[name=trpg-key])が不正です。");
const MEMO_KEY="trpg:"+FIXED_KEY+":memos";
const REPL_KEY="trpg:"+FIXED_KEY+":replacer";
let S={page:"info",index:new Map(),tags:new Set()}, ALL=[], ENT=new Map(), ID=new Map(), TAG_SIG="";

/* drawers & buttons */
const updIcon=()=>{ btnS.textContent=sea.classList.contains("open")?"▶":"◀"; };

// ドロワー閉じ時、文字変換の入力値を強制回収して適用（保険）
function flushToolInputs(){
  const inputs = document.querySelectorAll('#tocArea .input-box');
  let changed = false;
  inputs.forEach(inp=>{
    const word = inp.getAttribute('placeholder')||"";
    if (!word) return;
    const v = inp.value;
    if ((stateTool.values[word]||"") !== v){
      stateTool.values[word] = v;
      changed = true;
    }
  });
  if (changed) stateTool.dirty = true;
}

const setOpen=(el,on)=>{
  el.classList.toggle("open",!!on);
  if(el===sea) updIcon();
  if(on && el===toc) sea.classList.remove("open");
  if(!on && el===toc){            // ドロワー閉じ＝保険で適用
    flushToolInputs();
    applyReplacements_ifNeeded();
  }
};
btnT.onclick=()=>setOpen(toc,!toc.classList.contains("open"));
btnS.onclick=()=>setOpen(sea,!sea.classList.contains("open")); updIcon();
tabs.forEach(b=>b.onclick=()=>switchPage(b.dataset.target));
function switchPage(p){
  if(S.page===p) return;
  pages.forEach(sec=>sec.setAttribute("aria-hidden", sec.dataset.page===p?"false":"true"));
  tabs.forEach(b=>b.setAttribute("aria-current", b.dataset.target===p?"page":"false"));
  S.page=p; buildTOC_orTool(); buildChips(); if(sea.classList.contains("open")) search();
}

/* ===== headings, body text and index ===== */
function heads(sec){
  const hs=$$("h1,h2,h3",sec).map(h=>({el:h,l:+h.tagName[1],id:h.dataset.id||h.id,text:h.textContent.trim(),
                                        tags:(h.dataset.tags||"").split(/\s+/).filter(Boolean),children:[],parent:null,page:sec.dataset.page}));
  const st=[]; hs.forEach(x=>{while(st.length&&st.at(-1).l>=x.l)st.pop(); if(st.length){x.parent=st.at(-1); st.at(-1).children.push(x);} st.push(x);});
  return hs;
}
function collectText(root,{includeCode=false}={}){
  let out=""; const tw=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,{acceptNode(n){
    if(!n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
    const p=n.parentElement;
    if(p&&p.closest(".note")) return NodeFilter.FILTER_REJECT;
    if(!includeCode && p && p.closest("pre,code,.code")) return NodeFilter.FILTER_REJECT;
    return NodeFilter.FILTER_ACCEPT;
  }});
  while(tw.nextNode()) out+=" "+tw.currentNode.nodeValue.trim();
  return out.replace(/\s+/g," ").trim();
}
function bodyText(h){ // code除外の本文
  const L=h.tagName, stop=L==="H1"?/^(H1|H2|H3)$/:L==="H2"?/^(H2|H3)$/:/^H3$/;
  let s="", n=h.nextSibling;
  while(n){
    if(n.nodeType===1){ if(stop.test(n.tagName)) break; s+=" "+collectText(n); }
    else if(n.nodeType===3){ s+=" "+n.nodeValue.trim(); }
    n=n.nextSibling;
  }
  return s.replace(/\s+/g," ").trim();
}
function nearestHeading(el){
  let n=el.nodeType===1?el:el.parentElement; while(n){ if(n.matches?.("h1,h2,h3")) return n; n=n.parentElement; }
  n=el; while(n){ let p=n; while(p){ if(p.previousElementSibling){ p=p.previousElementSibling; if(p.matches?.("h1,h2,h3")) return p; } else { p=p.parentElement; if(!p) break; if(p.matches?.("h1,h2,h3")) return p; } } n=n.parentElement; }
  return null;
}
function buildIndex(){
  S.index.clear(); S.tags.clear(); ID.clear();
  pages.forEach(sec=>{
    const pg=sec.dataset.page, its=heads(sec), es=[], byId=new Map();
    its.forEach(it=>{
      const e={
        page:pg,id:it.id,lvl:it.l,text:it.text,
        body:bodyText(it.el),
        scope:(it.text+" "+bodyText(it.el)).trim(),
        scopeLower:(it.text+" "+bodyText(it.el)).trim().toLowerCase(),
        tags:[...new Set(it.tags)],parent:it.parent?.id||null,
        children:it.children.map(c=>c.id),el:it.el,order:undefined
      };
      it.tags.forEach(t=>S.tags.add(t)); es.push(e); byId.set(e.id,e); if(!ID.has(e.id)) ID.set(e.id,{text:e.text,page:pg,el:it.el});
    });
    es.forEach(e=>{let p=e.parent; while(p){const pe=byId.get(p); (pe.descendants??=new Set()).add(e.id); p=pe.parent;}});
    const elements=sec.querySelectorAll("h1,h2,h3,span.note"); let order=0;
    elements.forEach(el=>{
      if(el.matches("h1,h2,h3")){
        const id=el.dataset.id||el.id;
        const ent=byId.get(id);
        if(ent && ent.order===undefined) ent.order=order++;
      } else { // note
        const up=nearestHeading(el)||sec.querySelector("h1,h2,h3"); 
        if(!up) return;
        const parent=es.find(x=>x.el===up); 
        if(!parent) return;
        S.tags.add("メモ");
        const memoScope = (el.textContent + " " + (el.dataset.note || "")).trim();
        const memoId=parent.id+"::m::"+Math.random().toString(36).slice(2,8);
        (parent.descendants??=new Set()).add(memoId);
        es.push({
          kind:"memo",
          page:pg,
          id:memoId,
          lvl:3,
          scope: memoScope.slice(0,400),
          scopeLower: memoScope.toLowerCase().slice(0,400),
          text: el.textContent || "（メモ）",
          body: (el.dataset.note||""),
          sel: el.textContent,
          tags:["メモ"],
          parent: parent.id,
          children:[],
          el,
          descendants:new Set(),
          order:order++
        });
      }
    });
    es.forEach(e=>{if(e.order===undefined) e.order=order++;});
    S.index.set(pg,es);
  });
  ALL=[...(S.index.get("info")||[]),...(S.index.get("main")||[]),...(S.index.get("etc")||[])];
  ENT=new Map(ALL.map(e=>[e.id,e]));
}

/* ===== TOC or TOOL rendering ===== */
const stateTool={secOpen:{}, words:[], values:{}, composing:false, dirty:false, valuesInit:false};
function buildTOC_orTool(){
  const pcol=$("#tocPages"); pcol.innerHTML="";
  ["info","main","etc","tool"].forEach(n=>{
    const b=document.createElement("button"); b.textContent=n;
    const current=(S.page===n) || (n==="tool" && S.page==="tool");
    if(current) b.setAttribute("aria-current","page");
    b.onclick=()=>{ if(n==="tool"){ showToolPanel(); } else { switchPage(n); setOpen(toc,true); } };
    pcol.appendChild(b);
  });
  renderTOC_orToolArea();
}
function showToolPanel(){ S.page="tool"; renderTOC_orToolArea(); setOpen(toc,true); buildTOC_orTool(); }
function renderTOC_orToolArea(){
  const area=$("#tocArea"); area.innerHTML="";
  if(S.page==="tool") renderTool(area); else renderTOC(area);
}
function renderTOC(area){
  const sec=pages.find(p=>p.dataset.page===S.page);
  const its=heads(sec), roots=its.filter(x=>x.l===1), open=new Set();
  const row=(it,isOpen)=>{
    const d=document.createElement("div"); d.className="row";
    const tw=document.createElement("div"); tw.className="tw"; tw.textContent=it.children.length?(isOpen?"▼":"▶"):"•"; if(!it.children.length) tw.classList.add("off");
    const j=document.createElement("div"); j.textContent=it.text; j.className=it.l===2?"lvl2":it.l===3?"lvl3":"";
    if(it.children.length) tw.onclick=()=>{open.has(it)?open.delete(it):open.add(it); render();};
    j.onclick=()=>{ it.el.scrollIntoView({block:"start",behavior:"smooth"}); if(MOBILE()) toc.classList.remove("open"); };
    d.append(tw,j); return d;
  };
  const render=()=>{ area.innerHTML=""; roots.forEach(h1=>{ const o1=open.has(h1); area.appendChild(row(h1,o1));
    if(o1) h1.children.forEach(h2=>{ const o2=open.has(h2); area.appendChild(row(h2,o2));
      if(o2) h2.children.forEach(h3=>area.appendChild(row(h3,false))); }); }); };
  render();
}

/* ===== Tool Panel (TOC-like) ===== */
function readConvertWords(){
  try{
    const els = document.querySelectorAll('#convert-words');
    const el  = els[els.length - 1]; // 最後＝最新
    const obj = JSON.parse(el?.textContent || '{"words":[]}');
    return Array.isArray(obj.words) ? obj.words.filter(w => w && typeof w === "string") : [];
  }catch{ return []; }
}
function loadReplacerValues(){ try{ const v=JSON.parse(localStorage.getItem(REPL_KEY)||"{}"); return v&&typeof v==="object"?v:{}; }catch{ return {}; } }
function saveReplacerValues(){ try{ localStorage.setItem(REPL_KEY, JSON.stringify(stateTool.values)); }catch{} }
function renderTool(area){
  stateTool.words = readConvertWords();
  if(!stateTool.valuesInit){ stateTool.values = loadReplacerValues(); stateTool.valuesInit=true; }

  const addRow=(label, onToggle)=>{
    const d=document.createElement("div"); d.className="row";
    const tw=document.createElement("div"); tw.className="tw"; tw.textContent=stateTool.secOpen[label]?"▼":"▶";
    const j=document.createElement("div"); j.textContent=label;
    tw.onclick=()=>{ stateTool.secOpen[label]=!stateTool.secOpen[label]; onToggle(); };
    j.onclick=()=>{ stateTool.secOpen[label]=!stateTool.secOpen[label]; onToggle(); };
    d.append(tw,j); area.appendChild(d);
  };

  // H1: メモ管理
  addRow("メモ管理", ()=>renderTOC_orToolArea());
  if(stateTool.secOpen["メモ管理"]){
    const btn=document.createElement("button"); btn.className="btn danger"; btn.textContent="全メモ削除";
    btn.style.margin="6px 8px 12px";
    btn.onclick=()=>{ if(!confirm("全メモを削除します。よろしいですか？")) return; clearAllNotes(); buildIndex(); buildChips(); search(); alert("削除しました"); };
    area.appendChild(btn);
  }

  // H1: 文字変換
  addRow("文字変換", ()=>renderTOC_orToolArea());
  if(stateTool.secOpen["文字変換"]){
    if(!stateTool.words.length){
      const p=document.createElement("p"); p.style.margin="6px 8px 0"; p.textContent="◆ convert に語を 1行1語で列挙すると、ここに表示されます。";
      area.appendChild(p);
    }else{
      stateTool.words.forEach(word=>{
        // H2: 変換語（下線付き）
        const row=document.createElement("div"); row.className="row";
        const tw=document.createElement("div"); tw.className="tw"; tw.textContent=stateTool.secOpen[word]?"▼":"▶";
        const j=document.createElement("div"); j.textContent=word; j.classList.add("lvl2","tool-word");
        tw.onclick=()=>{ stateTool.secOpen[word]=!stateTool.secOpen[word]; renderTOC_orToolArea(); };
        j.onclick=()=>{ stateTool.secOpen[word]=!stateTool.secOpen[word]; renderTOC_orToolArea(); };
        row.append(tw,j); area.appendChild(row);

        if(stateTool.secOpen[word]){
          const wrap=document.createElement("div"); wrap.style.margin="0 8px 0 48px";
          const input=document.createElement("input"); input.type="text"; input.className="input-box";
          input.placeholder = word;                   /* プレースホルダー＝変換語だけ */
          input.value = stateTool.values[word] || "";

          // 即時適用（IME配慮）
          input.addEventListener("compositionstart",()=>{stateTool.composing=true;});
          input.addEventListener("compositionend",()=>{
            stateTool.composing=false; stateTool.values[word]=input.value; stateTool.dirty=true; applyReplacements_ifNeeded();
          });
          input.addEventListener("input",()=>{
            if(stateTool.composing) return;
            stateTool.values[word]=input.value; stateTool.dirty=true; applyReplacements_ifNeeded();
          });
          input.addEventListener("blur", ()=>{
            stateTool.values[word]=input.value; stateTool.dirty=true; applyReplacements_ifNeeded();
          });
          input.addEventListener("change",()=>{
            stateTool.values[word]=input.value; stateTool.dirty=true; applyReplacements_ifNeeded();
          });

          wrap.appendChild(input); area.appendChild(wrap);
        }
      });
    }
  }
}

 <script>
/* ===== Search ===== */
const q=$("#q"); let composing=false;
q.addEventListener("compositionstart",()=>composing=true);
q.addEventListener("compositionend",()=>{composing=false; search();});
q.addEventListener("input",()=>{ if(!composing) debounce(search,250)(); });
q.addEventListener("focus", clearHL);
const words=s=>(s||"").replace(/[　]/g," ").trim().split(/\s+/).filter(Boolean).map(w=>w.toLowerCase());
const debounce=(f,w=250)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>f(...a), w); }; };

function tokensForFilter(rawTokens){ return rawTokens.map(t=>t.toLowerCase()); } // 変換前のみでフィルタ
function tokensForHighlight(rawTokens){
  const values = stateTool.values || loadReplacerValues();
  const entries = Object.entries(values).filter(([k,v]) => typeof v === "string" && v.length);
  const mapFwd = new Map(entries.map(([k,v]) => [k.toLowerCase(), v.toLowerCase()])); // 原→変
  const mapRev = new Map(entries.map(([k,v]) => [v.toLowerCase(), k.toLowerCase()])); // 変→原
  const out = new Set();
  for(const t of rawTokens){
    const x = t.toLowerCase();
    out.add(x);
    const to = mapFwd.get(x);   if(to) out.add(to);
    const back = mapRev.get(x); if(back) out.add(back);
  }
  return [...out];
}

function buildChips(){
  if(!S || !S.index || S.index.size===0){ buildIndex(); }
  const tags=new Set(S.tags||[]); tags.add("メモ");
  const list=[...tags].filter(Boolean).sort();
  const sig=JSON.stringify(list);
  const wrap=$("#chips"); if(!wrap) return; 
  if(sig===TAG_SIG && wrap.children.length) return;
  TAG_SIG=sig; wrap.innerHTML="";
  const allBtn=document.createElement("button");
  allBtn.className="chip on"; allBtn.textContent="all"; allBtn.dataset.v="all"; allBtn.type="button";
  wrap.appendChild(allBtn);
  for(const n of list){
    const b=document.createElement("button");
    b.className="chip"; b.textContent=n; b.dataset.v=n; b.type="button";
    wrap.appendChild(b);
  }
  if(!wrap._bound){
    wrap.addEventListener("click",(ev)=>{
      const b=ev.target.closest(".chip"); if(!b) return;
      $$("#chips .chip").forEach(c=>c.classList.toggle("on",c===b));
      search();
    });
    wrap._bound=true;
  }
}

function search(){
  if(!ALL || !ALL.length){ buildIndex(); }
  const raw = words(q?.value||"");
  const filterT = tokensForFilter(raw);
  const hlT     = tokensForHighlight(raw);

  const tag=($("#chips .chip.on")?.dataset?.v)||"all";
  const cont=$("#res"); if(!cont) return; cont.innerHTML="";

  if(tag==="all" && filterT.length===0){
    const flat=[...(S.index.get("info")||[]),...(S.index.get("main")||[]),...(S.index.get("etc")||[])];
    return renderVirtual(flat.filter(e=>e.kind!=="memo"),[],true);
  }

  const hits=ALL.filter(e=>{
    const scope=(e.scopeLower||"");
    const okWords=filterT.every(w=>scope.includes(w));
    const okTag=(tag==="all")||(e.tags?.includes(tag));
    return okWords && okTag;
  });

  const idset=new Set(hits.map(h=>h.id));
  const filtered=hits.filter(e=>{
    const d=e.descendants||new Set();
    for(const c of d){ const ce=ENT.get(c); if(ce && ce.kind!=="memo" && idset.has(c)) return false; }
    return true;
  });
  renderVirtual(filtered,hlT,false);
}

const BATCH=100;
function crumb(e){ const es=S.index.get(e.page)||[]; if(e.lvl===1) return e.page;
  if(e.lvl===2){const p=es.find(x=>x.id===e.parent); return e.page+" ＞ "+(p?.text||"");}
  const p=es.find(x=>x.id===e.parent), p2=es.find(x=>x.id===p?.parent);
  return e.page+" ＞ "+(p2?.text||"")+" ＞ "+(p?.text||"");}

/* 見出しは含めず、本文クローンを返す（コピー/メモ等の相互作用は除去） */
function getHeadingRangeFragment(e){
  const h = e.el;
  const L = h.tagName;
  const stop = L==="H1" ? /^(H1|H2|H3)$/ : L==="H2" ? /^(H2|H3)$/ : /^H3$/;
  const frag=document.createDocumentFragment();
  let cur=h.nextSibling;
  while(cur){
    if(cur.nodeType===1){
      if(stop.test(cur.tagName)) break;
      frag.appendChild(cur.cloneNode(true));
    }else if(cur.nodeType===3){
      const span=document.createElement("span"); span.textContent=cur.nodeValue; frag.appendChild(span);
    }
    cur=cur.nextSibling;
  }
  // インタラクティブ要素の無効化
  frag.querySelectorAll(".note").forEach(s=>{ s.replaceWith(s.cloneNode(true)); });
  frag.querySelectorAll("pre.code .copy").forEach(b=>b.remove());
  return frag;
}

/* 見出し e.el の本文範囲で、最初の .hl-tmp を探す（カード用） */
function firstMarkUnderHeading(h){
  if(!h) return null;
  const L = h.tagName;
  const stop = L==="H1" ? /^(H1|H2|H3)$/ : L==="H2" ? /^(H2|H3)$/ : /^H3$/;
  let n = h.nextSibling;
  while(n){
    if(n.nodeType === 1){
      if (stop.test(n.tagName)) break;
      const m = n.querySelector(".hl-tmp");
      if (m) return m;
    }
    n = n.nextSibling;
  }
  return null;
}

/* カード：全文を一つのDOMで保持（閉＝省略、開＝そのまま全文） */
function makeCard(e, ws){
  const card=document.createElement("div"); card.className="card";

  const meta=document.createElement("div"); meta.className="meta";
  const jb=document.createElement("button"); jb.type="button"; jb.textContent="ジャンプ"; jb.className="btn";
  jb.onclick=(ev)=>{ev.stopPropagation(); jump(e,ws);};
  const bc=document.createElement("div"); bc.textContent=crumb(e);
  meta.append(bc,jb);

  const ttl=document.createElement("div"); ttl.className="title";
  ttl.textContent = (e.kind==="memo" ? "［メモ］"+(e.sel?e.sel.slice(0,30):"") : e.text);

  const content=document.createElement("div"); content.className="content";
  const full=document.createElement("div"); full.className="fulltext";

  if(e.kind==="memo"){
    // メモ本文を改行反映で表示（エスケープ＋<br>）
    const safe = (e.body||"")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/\n/g,"<br>");
    full.innerHTML = safe || "（メモなし）";
  }else{
    const frag=getHeadingRangeFragment(e);
    replaceInNodeTree(frag);
    full.appendChild(frag);
  }

  content.appendChild(full);
  card.append(meta,ttl,content);
  card.onclick=()=>{ card.classList.toggle("open"); };
  return card;
}

function renderVirtual(list,ws,preserve){
  const cont=$("#res"), arr=preserve?list:list.slice().sort(cmp);
  if(arr.length===0){ cont.textContent="該当なし"; return; }
  const sent=document.createElement("div"); sent.style.height="1px"; cont.appendChild(sent);
  let i=0; (function run(){ const end=Math.min(i+BATCH,arr.length); const df=document.createDocumentFragment(); for(;i<end;i++) df.appendChild(makeCard(arr[i],ws)); cont.insertBefore(df,sent);
    if(i<arr.length) (typeof requestIdleCallback==="function"?requestIdleCallback:(fn)=>setTimeout(fn,0))(()=>run()); else sent.remove(); })();
}

/* ===== highlight & links ===== */
function clearHL(){ $$(".hl-tmp",sc).forEach(m=>m.replaceWith(document.createTextNode(m.textContent))); }
function highlight(el,ws,includeCode=false){
  const root=(el.closest("section")||sc);
  const tw=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,{acceptNode(n){
    if(!n.nodeValue.trim())return NodeFilter.FILTER_REJECT;
    const p=n.parentElement;
    if(!includeCode && p && p.closest("pre,code,.code")) return NodeFilter.FILTER_REJECT;
    if(p && p.classList.contains("note")) return NodeFilter.FILTER_REJECT;
    return NodeFilter.FILTER_ACCEPT;
  }});
  const re=new RegExp("("+ws.map(w=>w.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\$&")).join("|")+")","ig"), targets=[];
  while(tw.nextNode()){const n=tw.currentNode; if(re.test(n.nodeValue)) targets.push(n);}
  targets.forEach(n=>{
    const parts=n.nodeValue.split(re), f=document.createDocumentFragment();
    parts.forEach(t=>{ if(!t) return; if(ws.some(w=>t.toLowerCase()===w.toLowerCase()))
      f.appendChild(Object.assign(document.createElement("mark"),{className:"hl-tmp",textContent:t}));
      else f.appendChild(document.createTextNode(t));
    });
    n.replaceWith(f);
  });
}

/* 一時ハイライト→ジャンプ */
function jump(e, tokens){
  clearHL();
  // 置換の同期（保険）
  applyReplacements_ifNeeded();

  const h = e.el;
  const sec = h.closest("section");
  sec?.scrollIntoView({block:"start"});

  if(tokens && tokens.length){
    // コードも含めてハイライト
    highlight(h, tokens, true);
    const m = firstMarkUnderHeading(h);
    if(m){
      const rect = m.getBoundingClientRect();
      const v = vp();
      const y = rect.top + window.scrollY - (v.h/2);
      window.scrollTo({top: y, behavior:"smooth"});
    }
  }

  if(MOBILE()) sea.classList.remove("open");
}
</script>
<script>
/* ===== 置換ロジック（完全一致のみ・境界なし／空欄は置換なし） ===== */
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }
function readConvertWords(){ // 再掲（他スコープからも使うため）
  try{
    const els = document.querySelectorAll('#convert-words');
    const el  = els[els.length - 1];
    const obj = JSON.parse(el?.textContent || '{"words":[]}');
    return Array.isArray(obj.words) ? obj.words.filter(w => w && typeof w === "string") : [];
  }catch{ return []; }
}
function loadReplacerValues(){ try{ const v=JSON.parse(localStorage.getItem(REPL_KEY)||"{}"); return v&&typeof v==="object"?v:{}; }catch{ return {}; } }
function saveReplacerValues(){ try{ localStorage.setItem(REPL_KEY, JSON.stringify(stateTool.values)); }catch{} }

// 完全一致の alternation を最長一致順で構築
function buildExactRegex(keys, { caseSensitive = true } = {}){
  const list = (keys || [])
    .filter(k => typeof k === "string" && k.length > 0)
    .sort((a,b) => b.length - a.length)
    .map(escapeRegExp);
  if (!list.length) return null;
  return new RegExp(`(?:${list.join("|")})`, caseSensitive ? "g" : "gi");
}

// 文字列中を完全一致で置換（空欄値は置換対象外＝原文保持）
function replaceInString_Exact(s){
  if (!s) return s;
  const values = stateTool?.values || loadReplacerValues();
  const entries = Object.entries(values).filter(([k,v]) => typeof k === "string" && typeof v === "string" && v.length > 0);
  if (!entries.length) return s;
  const map = new Map(entries);
  const re  = buildExactRegex(entries.map(([k]) => k), { caseSensitive: true });
  if (!re) return s;
  return s.replace(re, m => map.get(m) ?? m);
}

// DOMツリーに適用（見出し/コード/メモ/ジャンプリンクは除外）
function replaceInNodeTree(root){
  const values = stateTool?.values || loadReplacerValues();
  const hasActive = Object.values(values).some(v => typeof v === "string" && v.length > 0);
  if (!hasActive) return;

  const tw = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
    acceptNode(n){
      if (!n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
      const p = n.parentElement;
      if (p && (
        p.closest("pre,code,.code") ||
        p.closest(".note") ||
        p.closest("a[href^='#']") ||
        p.closest("h1,h2,h3")
      )) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  while (tw.nextNode()){
    const t = tw.currentNode;
    const next = replaceInString_Exact(t.nodeValue);
    if (t.nodeValue !== next) t.nodeValue = next;
  }
}

/* ===== スナップショット & 一括適用 ===== */
// 置換対象テキストノードのスナップショットを持ち、空欄時は完全復元
let snapshot=[];
function buildSnapshot(){
  snapshot.length=0;
  const root=sc;
  const tw=document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
    acceptNode(n){
      if(!n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
      const p=n.parentElement;
      if (p && (
        p.closest("pre,code,.code") ||
        p.closest(".note") ||
        p.closest("a[href^='#']") ||
        p.closest("h1,h2,h3")
      )) return NodeFilter.FILTER_REJECT;
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  while(tw.nextNode()){ snapshot.push({node:tw.currentNode, text:tw.currentNode.nodeValue}); }
}

function applyReplacements(){
  if (!snapshot.length) buildSnapshot();
  const values = stateTool?.values || loadReplacerValues();
  const hasActive = Object.values(values).some(v => typeof v === "string" && v.length > 0);

  if (!hasActive){
    // 全て空欄 → 完全復元
    snapshot.forEach(s => { if (s.node.nodeValue !== s.text) s.node.nodeValue = s.text; });
    return;
  }
  snapshot.forEach(s => {
    const next = replaceInString_Exact(s.text);
    if (s.node.nodeValue !== next) s.node.nodeValue = next;
  });
}

// デバウンス＋dirty監視で適用
let tApply=null;
function applyReplacements_ifNeeded(){
  if(!snapshot.length) buildSnapshot();
  if(!stateTool.dirty) return;
  clearTimeout(tApply);
  tApply=setTimeout(()=>{
    applyReplacements();
    stateTool.dirty=false;
    saveReplacerValues();
  }, 0);
}

/* ===== メモ機能 ===== */
const fab=$("#fab");
function clearAllNotes(){
  try{ localStorage.removeItem(MEMO_KEY); }catch{}
  // DOM上の .note を消す
  $$(".note",sc).forEach(n=>{
    const t=document.createTextNode(n.textContent||"");
    n.replaceWith(t);
  });
}
function restoreNotes(){
  let data=null; try{ data=JSON.parse(localStorage.getItem(MEMO_KEY)||"[]"); }catch{ data=null; }
  if(!Array.isArray(data)) return;
  data.forEach(entry=>{
    const {page,id,blockIndex,offset,length,text,note} = entry||{};
    const sec=pages.find(s=>s.dataset.page===page); if(!sec) return;
    const h = sec.querySelector(`[data-id="${id}"],#${id}`);
    if(!h) return;
    // 対象ブロック抽出
    const L=h.tagName, stop=L==="H1"?/^(H1|H2|H3)$/:L==="H2"?/^(H2|H3)$/:/^H3$/;
    const blocks=[]; let n=h.nextSibling;
    while(n){
      if(n.nodeType===1){ if(stop.test(n.tagName)) break; blocks.push(n); }
      else if(n.nodeType===3){ const span=document.createElement("span"); span.textContent=n.nodeValue; blocks.push(span); }
      n=n.nextSibling;
    }
    const blk=blocks[blockIndex]; if(!blk) return;
    // テキストノード列
    const tw=document.createTreeWalker(blk, NodeFilter.SHOW_TEXT, null);
    let i=0, acc=0, node=null, startOffset=0, remain=length;
    while(tw.nextNode()){
      const s=tw.currentNode.nodeValue||"";
      if(acc + s.length >= offset){
        node = tw.currentNode; startOffset = offset - acc; break;
      }
      acc += s.length;
    }
    if(!node) return;
    const range=document.createRange();
    range.setStart(node, Math.max(0,startOffset));
    // 終点探索
    let endNode=node, endOffset=Math.min(node.nodeValue.length, startOffset + remain);
    let left = remain - (endOffset - startOffset);
    while(left>0){
      const n2=nextTextNode(endNode, blk);
      if(!n2) break;
      endNode=n2;
      const add = Math.min(n2.nodeValue.length, left);
      endOffset = add;
      left -= add;
    }
    range.setEnd(endNode, endOffset);
    const span=document.createElement("span"); span.className="note"; span.dataset.note=note||""; span.textContent=text||range.toString();
    range.deleteContents(); range.insertNode(span);
  });
}
function nextTextNode(cur, root){
  const walker=document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  let found=false;
  while(walker.nextNode()){
    if(found) return walker.currentNode;
    if(walker.currentNode===cur) found=true;
  }
  return null;
}
function hookNotes(){
  // 右下＋ボタン
  function updateFab(){
    const sel=window.getSelection();
    const ok = sel && sel.rangeCount && !sel.isCollapsed && withinSingleBlock(sel);
    fab.classList.toggle("show", !!ok);
    if(ok){
      const r = sel.getRangeAt(0).getBoundingClientRect();
      fab.style.left = Math.min(window.innerWidth-60, Math.max(8, r.right+8))+"px";
      fab.style.top  = Math.min(window.innerHeight-60, Math.max(8, r.bottom+8))+"px";
    }
  }
  function withinSingleBlock(sel){
    const r=sel.getRangeAt(0);
    const a=blockAncestor(r.startContainer), b=blockAncestor(r.endContainer);
    return a && b && a===b && a.closest("section.page");
  }
  function blockAncestor(n){
    let e=n.nodeType===1?n:n.parentElement;
    while(e && !/^(P|LI|BLOCKQUOTE|PRE|DIV|H1|H2|H3)$/i.test(e.tagName)) e=e.parentElement;
    return e;
  }
  document.addEventListener("selectionchange", ()=>{ requestAnimationFrame(updateFab); });
  window.addEventListener("scroll", ()=>{ if(fab.classList.contains("show")) updateFab(); }, {passive:true});

  fab.addEventListener("click", ()=>{
    const sel=window.getSelection(); if(!sel||!sel.rangeCount) return;
    const range=sel.getRangeAt(0);
    const blk=blockAncestor(range.startContainer); if(!blk) return;
    const h=nearestHeading(blk)||blk.closest("section").querySelector("h1,h2,h3");
    if(!h) return;
    const page = h.closest("section").dataset.page;
    const id   = h.dataset.id||h.id;

    const chosen = range.toString().slice(0,300);
    const pop = makeMemoPopup(chosen, (memoText)=>{
      // 既存テキスト置換 → <span.note>
      const span=document.createElement("span"); span.className="note"; span.dataset.note=memoText||""; span.textContent=chosen;
      range.deleteContents(); range.insertNode(span);

      // オフセット保存
      const {blockIndex, offset, length} = locateSelection(blk, span);
      saveMemo({page,id,blockIndex,offset,length,text:chosen,note:memoText});
      buildIndex(); buildChips(); search();
    });
    document.body.appendChild(pop);
  }, false);
}
function locateSelection(block, span){
  // block 内で span までのテキスト長を数える
  const tw=document.createTreeWalker(block, NodeFilter.SHOW_TEXT, null);
  let acc=0, blockIndex=[...block.parentElement.childNodes].indexOf(block);
  while(tw.nextNode()){
    const n=tw.currentNode;
    if(span.compareDocumentPosition(n) & Node.DOCUMENT_POSITION_FOLLOWING){
      // span より先のノード
      break;
    }
    acc += (n.nodeValue||"").length;
  }
  const length=(span.textContent||"").length;
  // ざっくり: offset を block 先頭からとする
  const offset = calcTextOffset(block, span);
  return {blockIndex, offset, length};
}
function calcTextOffset(block, span){
  let offset=0;
  const tw=document.createTreeWalker(block, NodeFilter.SHOW_TEXT, null);
  while(tw.nextNode()){
    const n=tw.currentNode;
    if(span.contains(n)) break;
    offset += (n.nodeValue||"").length;
  }
  return offset;
}
function saveMemo(entry){
  let list=[]; try{ list=JSON.parse(localStorage.getItem(MEMO_KEY)||"[]"); }catch{ list=[]; }
  list.push(entry);
  try{ localStorage.setItem(MEMO_KEY, JSON.stringify(list)); }catch{}
}
function makeMemoPopup(selText, onSave){
  const wrap=document.createElement("div"); const bd=document.createElement("div"); const pop=document.createElement("div");
  wrap.className="backdrop"; bd.className="backdrop"; pop.className="pop";
  const h4=document.createElement("h4"); h4.textContent="メモの追加/編集";
  const ta=document.createElement("textarea"); ta.placeholder="メモ本文（改行可）";
  const acts=document.createElement("div"); acts.className="actions";
  const bSave=document.createElement("button"); bSave.className="btn primary"; bSave.textContent="保存";
  const bCancel=document.createElement("button"); bCancel.className="btn"; bCancel.textContent="キャンセル";
  acts.append(bSave,bCancel); pop.append(h4,ta,acts);
  function close(){ wrap.remove(); pop.remove(); }
  bCancel.onclick=close;
  bSave.onclick=()=>{ onSave?.(ta.value||""); close(); };
  wrap.onclick=close;
  document.body.append(wrap,pop);
  // 中央に配置
  const v=vp(); pop.style.left=(v.x + v.w/2 - pop.offsetWidth/2)+"px"; pop.style.top=(v.y + v.h/2 - pop.offsetHeight/2)+"px";
  return pop;
}

/* ===== コードコピー ===== */
function autoBoxCodes(){
  $$(".code .copy").forEach(btn=>{
    if(btn._bound) return; btn._bound=true;
    btn.addEventListener("click", async ()=>{
      const code=btn.parentElement.querySelector("code")?.innerText||"";
      try{
        await navigator.clipboard.writeText(code);
        btn.classList.add("done"); const old=btn.textContent; btn.textContent="copied ✓"; setTimeout(()=>{btn.textContent=old; btn.classList.remove("done");}, 1200);
      }catch{}
    });
  });
}

/* ===== リンク名補完 ===== */
function linkNames(){
  $$("a[href^='#']:not(:has(*))").forEach(a=>{
    if(a.textContent && a.textContent.trim()) return;
    const {page,id}=parseHash(a.getAttribute("href"));
    if(!id) return;
    const ent = page ? (ID.get(id)||{}) : (ID.get(id)||{});
    if(ent?.text) a.textContent=ent.text;
  });
}

/* ===== 初期化 ===== */
function init(){
  autoBoxCodes();
  restoreNotes();
  hookNotes();
  buildIndex();
  buildChips();
  linkNames();
  buildSnapshot();
  // 置換の初期適用（復元値があれば）
  stateTool.words = readConvertWords();
  if(!stateTool.valuesInit){ stateTool.values = loadReplacerValues(); stateTool.valuesInit=true; }
  stateTool.dirty=true; applyReplacements_ifNeeded();
}
document.addEventListener("DOMContentLoaded", init);

})();
</script>
</body>
</html>
