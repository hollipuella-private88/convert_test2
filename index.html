<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>TRPGã‚·ãƒŠãƒªã‚ªHTMLå¤‰æ›å™¨</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root{--bg:#0b1020;--fg:#e6e9f2;--mut:#9aa4bd;--line:#223;--acc:#2b5cff;--box:#121933}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.7 system-ui,-apple-system,"Segoe UI","Noto Sans JP","Yu Gothic UI","Meiryo",sans-serif}
header{padding:16px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center}
h1{font-size:18px;margin:0;font-weight:800}
main{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:16px}
section{background:var(--box);border:1px solid var(--line);border-radius:10px;padding:12px}
label{font-size:12px;color:var(--mut);display:block;margin-bottom:6px}
textarea{width:100%;height:60vh;background:#0b0f1a;color:#e8ebf5;border:1px solid #223;border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;resize:vertical}
.controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
input[type="file"]{display:block}
button{appearance:none;border:1px solid #355; background:#12203a; color:#e6e9f2; padding:.55em .9em; border-radius:8px; cursor:pointer}
button.primary{background:linear-gradient(180deg,#2b5cff,#244ddb);border-color:#1e3fb5}
button:disabled{opacity:.5;cursor:not-allowed}
.out{white-space:pre-wrap;word-break:break-word;background:#0b0f1a;border:1px dashed #334;border-radius:8px;padding:8px;max-height:60vh;overflow:auto}
kbd{background:#111a33;border:1px solid #334;border-radius:6px;padding:.1em .35em}
small{color:var(--mut)}
hr{border:none;border-top:1px solid var(--line);margin:10px 0}
.summary{font-size:13px;color:#c9d1ff}
</style>
</head>
<body>
<header>
  <h1>TRPGã‚·ãƒŠãƒªã‚ªHTMLå¤‰æ›å™¨</h1>
  <div class="summary">åŸç¨¿ï¼ˆãƒ†ã‚­ã‚¹ãƒˆï¼‰ï¼‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆHTMLï¼‰â†’ å®ŒæˆHTML ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</div>
</header>

<main>
  <section>
    <label>åŸç¨¿ï¼ˆãƒ†ã‚­ã‚¹ãƒˆ / 1è¡Œç›®=ã‚¿ã‚¤ãƒˆãƒ«, 2è¡Œç›®=å›ºå®šã‚­ãƒ¼, ä»¥é™æœ¬æ–‡ï¼‰</label>
    <textarea id="src" placeholder="1è¡Œç›®: ã‚¿ã‚¤ãƒˆãƒ«&#10;2è¡Œç›®: å›ºå®šã‚­ãƒ¼ï¼ˆA-Za-z0-9_-ï¼‰&#10;â—† info&#10;# è¦‹å‡ºã— @ã‚¿ã‚°&#10;æœ¬æ–‡...&#10;```&#10;ã‚³ãƒ¼ãƒ‰&#10;```&#10;â—† convert&#10;HO1&#10;PC"></textarea>
    <div class="controls">
      <input id="tplfile" type="file" accept=".html,.htm">
      <button id="btnGen" class="primary">å¤‰æ›ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
      <button id="btnLoadSample">ã‚µãƒ³ãƒ—ãƒ«åŸç¨¿ã‚’æŒ¿å…¥</button>
    </div>
    <small>ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæœªé¸æŠæ™‚ã¯ã€åŒãƒ•ã‚©ãƒ«ãƒ€ã® <kbd>template.html</kbd> ã‚’ãƒ•ã‚§ãƒƒãƒè©¦è¡Œã—ã¾ã™ã€‚</small>
  </section>

  <section>
    <label>ãƒ­ã‚° / å‡ºåŠ›ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆ</label>
    <div id="log" class="out">(ã“ã“ã«é€²è¡Œãƒ­ã‚°ãŒå‡ºã¾ã™)</div>
  </section>
</main>

<script>
(() => {
  "use strict";

  const $ = (s, r=document) => r.querySelector(s);
  const logEl = $("#log");
  const srcEl = $("#src");
  const tplEl = $("#tplfile");
  const btnGen = $("#btnGen");
  const btnSample = $("#btnLoadSample");

  const reEsc = s => s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");

  function log(...a){ logEl.textContent += "\n" + a.join(" "); logEl.scrollTop = logEl.scrollHeight; }
  function clearLog(){ logEl.textContent = ""; }

  // ---- Hash helper (stable short hash for IDs) ----
  function hashOf(str){
    // Simple 32-bit FNV-1a then base36
    let h=0x811c9dc5>>>0;
    for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h+((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)))>>>0; }
    return (h>>>0).toString(36);
  }

  // ---- Parsing ----

  function parseInput(raw){
    clearLog();
    if(!raw || !raw.trim()) throw new Error("åŸç¨¿ãŒç©ºã§ã™ã€‚");

    const lines = raw.replace(/\r\n?/g,"\n").split("\n");
    const title = (lines[0]||"").trim();
    const key   = (lines[1]||"").trim();
    if(!title) throw new Error("1è¡Œç›®ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ï¼‰ãŒç©ºã§ã™ã€‚");
    if(!/^[A-Za-z0-9_-]+$/.test(key)) throw new Error("2è¡Œç›®ï¼ˆå›ºå®šã‚­ãƒ¼ï¼‰ãŒä¸æ­£ã§ã™ã€‚è‹±æ•°å­—ãƒ»ãƒã‚¤ãƒ•ãƒ³ãƒ»ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ã€‚");

    const allowedPages = new Set(["info","main","etc","convert"]);
    let page = "info";   // default
    const pages = {info:[], main:[], etc:[], convert:[]};

    for(let i=2;i<lines.length;i++){
      const lineRaw = lines[i];
      const line = lineRaw.trim();
      if(/^â—†\s*(\S+)\s*$/.test(line)){
        const name = line.replace(/^â—†\s*/,"").trim();
        if(allowedPages.has(name)){
          page = name;
          continue;
        }
        // æœªçŸ¥ã® â—†xxx ã¯ä»•æ§˜ã«ã‚ˆã‚Šæœ¬æ–‡ã¨ã—ã¦æ®‹ã™ï¼šç¾åœ¨ã® page ã«ãã®ã¾ã¾ push
        pages[page].push(lineRaw);
        continue;
      }
      pages[page].push(lineRaw);
    }

    // convert èªï¼ˆ1è¡Œ1èªã€ç©ºè¡Œãƒ»ç©ºç™½è¡Œã¯ç„¡è¦–ï¼‰
    const convertWords = (pages.convert || [])
      .map(s => s.trim())
      .filter(s => s.length>0);

    return { title, key, pages, convertWords };
  }

  // ãƒ˜ãƒƒãƒ‡ã‚£ãƒ³ã‚° & æ§‹é€ 
  function makeHeading(line){
    // "# H1 @tag1 @tag2" / "## H2" / "### H3"
    const m = line.match(/^(#{1,3})\s+(.*)$/);
    if(!m) return null;
    const level = m[1].length;
    let rest = m[2].trim();

    // æœ«å°¾ @tags
    const tags = [];
    rest = rest.replace(/\s+@([^\s@]+)\b/g,(all,t)=>{
      if(t==="ãƒ¡ãƒ¢") throw new Error("@ãƒ¡ãƒ¢ ã¯ç¦æ­¢ã§ã™ã€‚");
      tags.push(t);
      return "";
    }).trim();

    return { level, text: rest, tags };
  }

  // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æŠ½å‡º
  function readCodeBlock(lines, i){
    // é–‹å§‹è¡Œã¯ ```xxx or '''xxx
    const start = lines[i];
    const fence = start.startsWith("```") ? "```" : "'''";
    const out = [];
    i++;
    for(; i<lines.length; i++){
      const line = lines[i];
      if(line.startsWith(fence)){
        return { next:i, code: out.join("\n") };
      }
      out.push(line);
    }
    // æœªé–‰ã˜ã¯æœ€å¾Œã¾ã§
    return { next:i-1, code: out.join("\n") };
  }

  // ãƒšãƒ¼ã‚¸->ãƒãƒ¼ãƒ‰é…åˆ—ã¸å¤‰æ›
  function parsePageLines(lines){
    const nodes = []; // {type:"h"|"p"|"code"|"blank", ...}
    for(let i=0;i<lines.length;i++){
      const raw = lines[i];
      const line = raw;

      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹ï¼Ÿ
      if(line.trim().startsWith("```") || line.trim().startsWith("'''")){
        const {next, code} = readCodeBlock(lines, i);
        nodes.push({ type:"code", code });
        i = next;
        continue;
      }

      const h = makeHeading(line.trim());
      if(h){
        nodes.push({type:"h", level:h.level, text:h.text, tags:h.tags});
        continue;
      }

      if(line.trim()===""){
        nodes.push({type:"blank"});
      }else{
        nodes.push({type:"p", text: line});
      }
    }
    return nodes;
  }

  // æ§‹é€ æœ¨ã‚’ä½œã‚‹ï¼ˆH1/H2/H3ï¼‰
  function buildStructure(nodes){
    const items = []; // [{type:"h",level,text,tags,children:[],parent:null, id:""} or p/code]
    const stack = [];
    for(const n of nodes){
      if(n.type==="h"){
        const item = { ...n, children:[], parent:null, id:"" };
        while(stack.length && stack.at(-1).level >= n.level) stack.pop();
        if(stack.length){
          item.parent = stack.at(-1);
          stack.at(-1).children.push(item);
        }
        stack.push(item);
        items.push(item);
      }else{
        items.push(n);
      }
    }
    return items;
  }

  // è¦‹å‡ºã—IDï¼ˆé‡è¤‡ãƒ¦ãƒ‹ãƒ¼ã‚¯åŒ–ï¼‰
  function assignIds(items){
    const used = new Map(); // textPath -> count
    function walk(item, path){
      const cur = [...path, item.text].join(">");
      const base = hashOf(cur);
      const k = base;
      const count = (used.get(k)||0);
      used.set(k, count+1);
      const id = count? `${base}-${count}` : base;
      item.id = id;
      item.textPath = [...path, item.text]; // for resolver
      for(const c of item.children) walk(c, [...path, item.text]);
    }
    for(const it of items){
      if(it.type==="h" && it.level===1){
        walk(it, []);
      }
    }
  }

  // ãƒšãƒ¼ã‚¸è¾æ›¸ï¼ˆè§£æ±ºç”¨ï¼‰
  function buildHeadingDict(items){
    // è¾æ›¸ï¼šå˜ä½“åï¼ˆæœ€ä¸‹ä½ï¼‰ã¨éšå±¤åï¼ˆ>åŒºåˆ‡ã‚Šï¼‰ã®ä¸¡æ–¹ã§è§£æ±ºå¯
    const single = new Map(); // name -> idï¼ˆæœ€å¾Œã«ç¾ã‚ŒãŸã‚‚ã®ã‚’å„ªå…ˆï¼‰
    const full   = new Map(); // "H1>H2>H3" -> id
    function visit(h){
      const id = h.id;
      full.set(h.textPath.join(">"), id);
      single.set(h.text, id);
      for(const c of h.children) visit(c);
    }
    for(const it of items){
      if(it.type==="h" && it.level===1) visit(it);
    }
    return { single, full };
  }

  // ---- æ®µè½ï¼šã‚¸ãƒ£ãƒ³ãƒ—è¨˜æ³• + ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è£…é£¾ ----

  // ä»•æ§˜ã«åˆã‚ã›ãŸå˜ä¸€æ­£è¦è¡¨ç¾ï¼š  â—†page#H1##H2###H3  /  #H1##H2###H3
  // ï¼ˆå·¦å³å¢ƒç•Œï¼šå·¦=è¡Œé ­/ç©ºç™½ã€å³=ç©ºç™½/è¡Œæœ«ï¼‰
  function formatParagraphToNodes(line, ctx){
    const frag = document.createDocumentFragment();
    const re = /(?:â—†([A-Za-z0-9_-]+))?(\s*)#([^#\s]+)(?:##([^#\s]+))?(?:###([^#\s]+))?/g;
    let last = 0, m;

    const leftBoundary = (s,i)=> i===0 || /\s/.test(s[i-1]);
    const rightBoundary= (s,j)=> j===s.length || /\s/.test(s[j]);

    while((m = re.exec(line))){
      const start = m.index;
      const end   = re.lastIndex;
      if(!leftBoundary(line, start) || !rightBoundary(line, end)){
        continue; // åŸæ–‡ç¶­æŒï¼šã‚¹ã‚­ãƒƒãƒ—ï¼ˆå¾Œã§ã¾ã¨ã‚ã¦ãƒ†ã‚­ã‚¹ãƒˆæ‰±ã„ï¼‰
      }

      // ç›´å‰ãƒ†ã‚­ã‚¹ãƒˆ
      if(start>last){
        frag.appendChild(applyInlineMarks(line.slice(last, start), document));
      }

      const pg  = m[1] || ctx.page;
      const h1  = m[3], h2=m[4], h3=m[5];
      const path = [h1,h2,h3].filter(Boolean);

      const id = resolveId(ctx, pg, path);
      if(!id){
        // æœªè§£æ±ºï¼šåŸæ–‡ã‚’ãã®ã¾ã¾
        frag.appendChild(applyInlineMarks(line.slice(start, end), document));
      }else{
        const a = document.createElement("a");
        a.href = (m[1] ? `#${pg}:${id}` : `#${id}`);
        a.textContent = path.at(-1);
        frag.appendChild(a);
      }
      last = end;
    }
    if(last < line.length){
      frag.appendChild(applyInlineMarks(line.slice(last), document));
    }
    return frag;
  }

  // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è£…é£¾ï¼ˆå…¥ã‚Œå­éå¯¾å¿œã®è»½é‡ç‰ˆï¼‰ï¼š** / * / __ / ~~
  function applyInlineMarks(text, doc){
    // ã¾ãšãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã‹ã‚‰é–‹å§‹ã—ã€é †æ¬¡ãƒ©ãƒƒãƒ—
    // ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œæ–‡å­—åˆ—â†’ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã€ç”Ÿæˆ
    const wrap = (s,re,tag)=>{
      const frag = doc.createDocumentFragment();
      let last = 0, m;
      while((m = re.exec(s))){
        if(m.index>last) frag.appendChild(doc.createTextNode(s.slice(last,m.index)));
        const el = doc.createElement(tag);
        el.textContent = m[1];
        frag.appendChild(el);
        last = re.lastIndex;
      }
      if(last < s.length) frag.appendChild(doc.createTextNode(s.slice(last)));
      return frag;
    };
    // ** â†’ * â†’ __ â†’ ~~ ã®é †ã«é©ç”¨ï¼ˆå…¥ã‚Œå­éå¯¾å¿œï¼‰
    const reBold   = /\*\*([^*\n]+)\*\*/gy;
    const reItalic = /\*([^*\n]+)\*/gy;
    const reUline  = /__([^_\n]+)__/gy;
    const reStrike = /~~([^~\n]+)~~/gy;

    // æ®µéšé©ç”¨ã®ãŸã‚ã€éƒ½åº¦ãƒ†ã‚­ã‚¹ãƒˆåŒ–â†’å†ãƒ©ãƒƒãƒ—
    const step1 = wrap(text, reBold, "strong");
    const s1 = Array.from(step1.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    const step2 = wrap(s1, reItalic, "em");
    const s2 = Array.from(step2.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    const step3 = wrap(s2, reUline, "u");
    const s3 = Array.from(step3.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    return wrap(s3, reStrike, "s");
  }

  // ---- ãƒªã‚¾ãƒ«ãƒ ----

  function resolveId(ctx, page, path){
    // å„ªå…ˆï¼šéšå±¤åï¼ˆH1>H2>H3ï¼‰ã€æ¬¡ã«å˜ä½“åï¼ˆæœ€ä¸‹ä½ï¼‰
    const dict = ctx.dicts.get(page);
    if(!dict) return null;
    if(path.length){
      const fullKey = path.join(">");
      if(dict.full.has(fullKey)) return dict.full.get(fullKey);
      const leaf = path.at(-1);
      if(dict.single.has(leaf)) return dict.single.get(leaf);
    }
    return null;
  }

  // ---- HTMLæ§‹ç¯‰ ----

  function buildHTML(parsed, templateHTML){
    const parser = new DOMParser();
    const doc = parser.parseFromString(templateHTML, "text/html");
    if(!doc || !doc.querySelector) throw new Error("ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚");

    // ã‚¿ã‚¤ãƒˆãƒ« / ã‚­ãƒ¼åŸ‹ã‚è¾¼ã¿
    const tplStr = doc.documentElement.outerHTML
      .replaceAll("{{TITLE}}", escapeHtmlText(parsed.title))
      .replaceAll("{{KEY}}", escapeHtmlText(parsed.key));

    const doc2 = parser.parseFromString(tplStr, "text/html");

    // ãƒšãƒ¼ã‚¸ã”ã¨ã«æ§‹æ–‡æœ¨åŒ–
    const resPerPage = new Map(); // page -> {items, dict, htmlFragment}
    const ctx = { page:null, dicts:new Map() };

    ["info","main","etc"].forEach(page=>{
      const nodes = parsePageLines(parsed.pages[page]||[]);
      const items = buildStructure(nodes);
      assignIds(items);
      const dict = buildHeadingDict(items);
      resPerPage.set(page, {items, dict});
      ctx.dicts.set(page, dict);
    });

    // ä¸€æ—¦ dicts ãã‚ã£ãŸã®ã§ã€æ®µè½â†’HTMLç”Ÿæˆ
    ["info","main","etc"].forEach(page=>{
      const {items} = resPerPage.get(page);
      const sec = doc2.querySelector(`.page[data-page="${page}"]`);
      if(!sec) return;
      sec.innerHTML = ""; // ç½®æ›

      const ctxPage = { page, dicts: ctx.dicts };

      // items ã‚’é †ã«HTMLã¸
      const stack = []; // current parent for appending
      const append = (el) => { (stack.at(-1)||sec).appendChild(el); };

      for(const it of items){
        if(it.type==="h"){
          const tag = it.level===1?"h1":it.level===2?"h2":"h3";
          const h = doc2.createElement(tag);
          h.textContent = it.text;           // è¦‹å‡ºã—ã¯ textContent ãƒ™ãƒ¼ã‚¹
          h.id = it.id;
          h.dataset.id = it.id;
          if(it.tags && it.tags.length) h.dataset.tags = it.tags.join(" ");
          sec.appendChild(h);
          // ãƒ•ãƒ­ãƒ¼ä¸Šï¼šè¦‹å‡ºã—ã¯ç›´æ¥ sec ã«ç©ã‚€ï¼ˆä¸­èº«ã®æ®µè½ã¯è¦‹å‡ºã—ã®æ¬¡å…„å¼Ÿã¨ã—ã¦ç¶šãï¼‰
        }else if(it.type==="p"){
          const p = doc2.createElement("p");
          // p å†…ã¯ textContent ãƒ™ãƒ¼ã‚¹ã ãŒã€ã‚¸ãƒ£ãƒ³ãƒ—è¨˜æ³•ã¯ a ã§å·®ã—è¾¼ã‚€
          const frag = formatParagraphToNodes(it.text, ctxPage);
          p.appendChild(frag);
          sec.appendChild(p);
        }else if(it.type==="code"){
          const pre = doc2.createElement("pre"); pre.className="code";
          const btn = doc2.createElement("button"); btn.className="copy"; btn.textContent="copy";
          const code = doc2.createElement("code");
          code.textContent = it.code;
          pre.append(btn, code);
          sec.appendChild(pre);
        }else if(it.type==="blank"){
          // ç©ºè¡Œã¯æ®µè½é–“ã®ä½™ç™½ï¼š<p>ã‚’ä½œã‚‰ãšã‚¹ã‚­ãƒƒãƒ—
        }
      }
    });

    // â—† convert ã®èªã‚’ JSON ã§åŸ‹ã‚è¾¼ã¿ï¼ˆæ—¢å­˜ãŒãªã‘ã‚Œã°ä½œæˆã—ã¦ body æœ«å°¾ã¸ï¼‰
    const words = parsed.convertWords || [];
    const json  = JSON.stringify({words});
    let node    = doc2.querySelector("#convert-words");
    if(!node){
      node = doc2.createElement("script");
      node.id = "convert-words";
      node.type = "application/json";
      doc2.body.appendChild(node);
    }
    node.textContent = json;

    return "<!doctype html>\n" + doc2.documentElement.outerHTML;
  }

  // ---- Utils ----
  function escapeHtmlText(s){
    return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // ---- I/O: template èª­ã¿è¾¼ã¿ ----
  async function readTemplateFromPicker(){
    if(tplEl.files && tplEl.files[0]){
      return await tplEl.files[0].text();
    }
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŒéšå±¤ã® template.html ã‚’è©¦ã—ã«å–å¾—
    try{
      const res = await fetch("./template.html", {cache:"no-store"});
      if(!res.ok) throw new Error();
      return await res.text();
    }catch{
      throw new Error("ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆHTMLãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ or åŒéšå±¤ã® template.html ãŒå¿…è¦ï¼‰ã€‚");
    }
  }

  // ---- å¤‰æ›å®Ÿè¡Œ ----
  btnGen.addEventListener("click", async () => {
    try{
      btnGen.disabled = true;
      clearLog();
      log("â–¶ å¤‰æ›é–‹å§‹â€¦");

      const raw = srcEl.value;
      const parsed = parseInput(raw);
      log("âœ“ åŸç¨¿è§£æ:", `title="${parsed.title}" key="${parsed.key}"`);
      log("  - info:", (parsed.pages.info||[]).length, "è¡Œ");
      log("  - main:", (parsed.pages.main||[]).length, "è¡Œ");
      log("  - etc :", (parsed.pages.etc ||[]).length, "è¡Œ");
      log("  - convert èª:", parsed.convertWords.length, "ä»¶");

      const tpl = await readTemplateFromPicker();
      log("âœ“ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆèª­è¾¼ OK");

      const out = buildHTML(parsed, tpl);
      log("âœ“ HTMLæ§‹ç¯‰ OK");

      const fname = sanitizeFileName(parsed.title || "scenario") + ".html";
      downloadText(fname, out);
      log("âœ“ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰:", fname);
      log("å®Œäº† ğŸ‰");
    }catch(err){
      console.error(err);
      alert(err.message || String(err));
      log("âœ— ã‚¨ãƒ©ãƒ¼:", err.message || String(err));
    }finally{
      btnGen.disabled = false;
    }
  });

  function sanitizeFileName(name){
    return name.replace(/[\\\/:*?"<>|]/g,"_").slice(0,128) || "scenario";
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/html;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
  }

  // ---- ã‚µãƒ³ãƒ—ãƒ« ----
  btnSample.addEventListener("click", ()=>{
    srcEl.value =
`ã‚µãƒ³ãƒ—ãƒ«ã‚·ãƒŠãƒªã‚ª
SAMPLE_KEY
â—† info
# æ–‡å­—å¤‰æ›
## KPC @é‡è¦
### ã“ã“ã¯H3
KPC ã¯ *æ¢ç´¢è€…* ã‚’æŒ‡ã™ç”¨èªã§ã™ã€‚~~èª¤è¨˜~~ ã‚‚ã‚ã‚Šã¾ã™ã€‚
'''js
console.log("hello KPC");
'''
# å°å…¥
## ã‚ã‚‰ã™ã˜
HO1 ã¨ PC ãŒç™»å ´ã—ã¾ã™ã€‚#æ–‡å­—å¤‰æ›##KPC ã«ã‚‚ã‚¸ãƒ£ãƒ³ãƒ—ã§ãã¾ã™ã€‚

â—† main
# æœ¬ç·¨
## ç¬¬ä¸€ç« 
æœ¬æ–‡ã€‚â—†info#å°å…¥##ã‚ã‚‰ã™ã˜ ã¸ã‚¸ãƒ£ãƒ³ãƒ—ã§ãã¾ã™ã€‚

â—† etc
# ä»˜è¨˜
__ä¸‹ç·š__ ã¨ **å¤ªå­—** ã®ãƒ†ã‚¹ãƒˆã€‚

â—† convert
HO1
PC
KPC`;
    log("âœ“ ã‚µãƒ³ãƒ—ãƒ«åŸç¨¿ã‚’æŒ¿å…¥ã—ã¾ã—ãŸã€‚");
  });

})();
</script>
</body>
</html>