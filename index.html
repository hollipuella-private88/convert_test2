<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>TRPGシナリオHTML変換器</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root{--bg:#0b1020;--fg:#e6e9f2;--mut:#9aa4bd;--line:#223;--acc:#2b5cff;--box:#121933}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.7 system-ui,-apple-system,"Segoe UI","Noto Sans JP","Yu Gothic UI","Meiryo",sans-serif}
header{padding:16px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center}
h1{font-size:18px;margin:0;font-weight:800}
main{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:16px}
section{background:var(--box);border:1px solid var(--line);border-radius:10px;padding:12px}
label{font-size:12px;color:var(--mut);display:block;margin-bottom:6px}
textarea{width:100%;height:60vh;background:#0b0f1a;color:#e8ebf5;border:1px solid #223;border-radius:8px;padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;resize:vertical}
.controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
input[type="file"]{display:block}
button{appearance:none;border:1px solid #355; background:#12203a; color:#e6e9f2; padding:.55em .9em; border-radius:8px; cursor:pointer}
button.primary{background:linear-gradient(180deg,#2b5cff,#244ddb);border-color:#1e3fb5}
button:disabled{opacity:.5;cursor:not-allowed}
.out{white-space:pre-wrap;word-break:break-word;background:#0b0f1a;border:1px dashed #334;border-radius:8px;padding:8px;max-height:60vh;overflow:auto}
kbd{background:#111a33;border:1px solid #334;border-radius:6px;padding:.1em .35em}
small{color:var(--mut)}
hr{border:none;border-top:1px solid var(--line);margin:10px 0}
.summary{font-size:13px;color:#c9d1ff}
</style>
</head>
<body>
<header>
  <h1>TRPGシナリオHTML変換器</h1>
  <div class="summary">原稿（テキスト）＋テンプレート（HTML）→ 完成HTML を生成します。</div>
</header>

<main>
  <section>
    <label>原稿（テキスト / 1行目=タイトル, 2行目=固定キー, 以降本文）</label>
    <textarea id="src" placeholder="1行目: タイトル&#10;2行目: 固定キー（A-Za-z0-9_-）&#10;◆ info&#10;# 見出し @タグ&#10;本文...&#10;```&#10;コード&#10;```&#10;◆ convert&#10;HO1&#10;PC"></textarea>
    <div class="controls">
      <input id="tplfile" type="file" accept=".html,.htm">
      <button id="btnGen" class="primary">変換してダウンロード</button>
      <button id="btnLoadSample">サンプル原稿を挿入</button>
    </div>
    <small>テンプレート未選択時は、同フォルダの <kbd>template.html</kbd> をフェッチ試行します。</small>
  </section>

  <section>
    <label>ログ / 出力ダイジェスト</label>
    <div id="log" class="out">(ここに進行ログが出ます)</div>
  </section>
</main>

<script>
(() => {
  "use strict";

  const $ = (s, r=document) => r.querySelector(s);
  const logEl = $("#log");
  const srcEl = $("#src");
  const tplEl = $("#tplfile");
  const btnGen = $("#btnGen");
  const btnSample = $("#btnLoadSample");

  const reEsc = s => s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");

  function log(...a){ logEl.textContent += "\n" + a.join(" "); logEl.scrollTop = logEl.scrollHeight; }
  function clearLog(){ logEl.textContent = ""; }

  // ---- Hash helper (stable short hash for IDs) ----
  function hashOf(str){
    // Simple 32-bit FNV-1a then base36
    let h=0x811c9dc5>>>0;
    for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h+((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)))>>>0; }
    return (h>>>0).toString(36);
  }

  // ---- Parsing ----

  function parseInput(raw){
    clearLog();
    if(!raw || !raw.trim()) throw new Error("原稿が空です。");

    const lines = raw.replace(/\r\n?/g,"\n").split("\n");
    const title = (lines[0]||"").trim();
    const key   = (lines[1]||"").trim();
    if(!title) throw new Error("1行目（タイトル）が空です。");
    if(!/^[A-Za-z0-9_-]+$/.test(key)) throw new Error("2行目（固定キー）が不正です。英数字・ハイフン・アンダースコアのみ。");

    const allowedPages = new Set(["info","main","etc","convert"]);
    let page = "info";   // default
    const pages = {info:[], main:[], etc:[], convert:[]};

    for(let i=2;i<lines.length;i++){
      const lineRaw = lines[i];
      const line = lineRaw.trim();
      if(/^◆\s*(\S+)\s*$/.test(line)){
        const name = line.replace(/^◆\s*/,"").trim();
        if(allowedPages.has(name)){
          page = name;
          continue;
        }
        // 未知の ◆xxx は仕様により本文として残す：現在の page にそのまま push
        pages[page].push(lineRaw);
        continue;
      }
      pages[page].push(lineRaw);
    }

    // convert 語（1行1語、空行・空白行は無視）
    const convertWords = (pages.convert || [])
      .map(s => s.trim())
      .filter(s => s.length>0);

    return { title, key, pages, convertWords };
  }

  // ヘッディング & 構造
  function makeHeading(line){
    // "# H1 @tag1 @tag2" / "## H2" / "### H3"
    const m = line.match(/^(#{1,3})\s+(.*)$/);
    if(!m) return null;
    const level = m[1].length;
    let rest = m[2].trim();

    // 末尾 @tags
    const tags = [];
    rest = rest.replace(/\s+@([^\s@]+)\b/g,(all,t)=>{
      if(t==="メモ") throw new Error("@メモ は禁止です。");
      tags.push(t);
      return "";
    }).trim();

    return { level, text: rest, tags };
  }

  // コードブロック抽出
  function readCodeBlock(lines, i){
    // 開始行は ```xxx or '''xxx
    const start = lines[i];
    const fence = start.startsWith("```") ? "```" : "'''";
    const out = [];
    i++;
    for(; i<lines.length; i++){
      const line = lines[i];
      if(line.startsWith(fence)){
        return { next:i, code: out.join("\n") };
      }
      out.push(line);
    }
    // 未閉じは最後まで
    return { next:i-1, code: out.join("\n") };
  }

  // ページ->ノード配列へ変換
  function parsePageLines(lines){
    const nodes = []; // {type:"h"|"p"|"code"|"blank", ...}
    for(let i=0;i<lines.length;i++){
      const raw = lines[i];
      const line = raw;

      // コードブロック開始？
      if(line.trim().startsWith("```") || line.trim().startsWith("'''")){
        const {next, code} = readCodeBlock(lines, i);
        nodes.push({ type:"code", code });
        i = next;
        continue;
      }

      const h = makeHeading(line.trim());
      if(h){
        nodes.push({type:"h", level:h.level, text:h.text, tags:h.tags});
        continue;
      }

      if(line.trim()===""){
        nodes.push({type:"blank"});
      }else{
        nodes.push({type:"p", text: line});
      }
    }
    return nodes;
  }

  // 構造木を作る（H1/H2/H3）
  function buildStructure(nodes){
    const items = []; // [{type:"h",level,text,tags,children:[],parent:null, id:""} or p/code]
    const stack = [];
    for(const n of nodes){
      if(n.type==="h"){
        const item = { ...n, children:[], parent:null, id:"" };
        while(stack.length && stack.at(-1).level >= n.level) stack.pop();
        if(stack.length){
          item.parent = stack.at(-1);
          stack.at(-1).children.push(item);
        }
        stack.push(item);
        items.push(item);
      }else{
        items.push(n);
      }
    }
    return items;
  }

  // 見出しID（重複ユニーク化）
  function assignIds(items){
    const used = new Map(); // textPath -> count
    function walk(item, path){
      const cur = [...path, item.text].join(">");
      const base = hashOf(cur);
      const k = base;
      const count = (used.get(k)||0);
      used.set(k, count+1);
      const id = count? `${base}-${count}` : base;
      item.id = id;
      item.textPath = [...path, item.text]; // for resolver
      for(const c of item.children) walk(c, [...path, item.text]);
    }
    for(const it of items){
      if(it.type==="h" && it.level===1){
        walk(it, []);
      }
    }
  }

  // ページ辞書（解決用）
  function buildHeadingDict(items){
    // 辞書：単体名（最下位）と階層名（>区切り）の両方で解決可
    const single = new Map(); // name -> id（最後に現れたものを優先）
    const full   = new Map(); // "H1>H2>H3" -> id
    function visit(h){
      const id = h.id;
      full.set(h.textPath.join(">"), id);
      single.set(h.text, id);
      for(const c of h.children) visit(c);
    }
    for(const it of items){
      if(it.type==="h" && it.level===1) visit(it);
    }
    return { single, full };
  }

  // ---- 段落：ジャンプ記法 + インライン装飾 ----

  // 仕様に合わせた単一正規表現：  ◆page#H1##H2###H3  /  #H1##H2###H3
  // （左右境界：左=行頭/空白、右=空白/行末）
  function formatParagraphToNodes(line, ctx){
    const frag = document.createDocumentFragment();
    const re = /(?:◆([A-Za-z0-9_-]+))?(\s*)#([^#\s]+)(?:##([^#\s]+))?(?:###([^#\s]+))?/g;
    let last = 0, m;

    const leftBoundary = (s,i)=> i===0 || /\s/.test(s[i-1]);
    const rightBoundary= (s,j)=> j===s.length || /\s/.test(s[j]);

    while((m = re.exec(line))){
      const start = m.index;
      const end   = re.lastIndex;
      if(!leftBoundary(line, start) || !rightBoundary(line, end)){
        continue; // 原文維持：スキップ（後でまとめてテキスト扱い）
      }

      // 直前テキスト
      if(start>last){
        frag.appendChild(applyInlineMarks(line.slice(last, start), document));
      }

      const pg  = m[1] || ctx.page;
      const h1  = m[3], h2=m[4], h3=m[5];
      const path = [h1,h2,h3].filter(Boolean);

      const id = resolveId(ctx, pg, path);
      if(!id){
        // 未解決：原文をそのまま
        frag.appendChild(applyInlineMarks(line.slice(start, end), document));
      }else{
        const a = document.createElement("a");
        a.href = (m[1] ? `#${pg}:${id}` : `#${id}`);
        a.textContent = path.at(-1);
        frag.appendChild(a);
      }
      last = end;
    }
    if(last < line.length){
      frag.appendChild(applyInlineMarks(line.slice(last), document));
    }
    return frag;
  }

  // インライン装飾（入れ子非対応の軽量版）：** / * / __ / ~~
  function applyInlineMarks(text, doc){
    // まずプレーンテキストノードから開始し、順次ラップ
    // シンプルに「文字列→フラグメント」生成
    const wrap = (s,re,tag)=>{
      const frag = doc.createDocumentFragment();
      let last = 0, m;
      while((m = re.exec(s))){
        if(m.index>last) frag.appendChild(doc.createTextNode(s.slice(last,m.index)));
        const el = doc.createElement(tag);
        el.textContent = m[1];
        frag.appendChild(el);
        last = re.lastIndex;
      }
      if(last < s.length) frag.appendChild(doc.createTextNode(s.slice(last)));
      return frag;
    };
    // ** → * → __ → ~~ の順に適用（入れ子非対応）
    const reBold   = /\*\*([^*\n]+)\*\*/gy;
    const reItalic = /\*([^*\n]+)\*/gy;
    const reUline  = /__([^_\n]+)__/gy;
    const reStrike = /~~([^~\n]+)~~/gy;

    // 段階適用のため、都度テキスト化→再ラップ
    const step1 = wrap(text, reBold, "strong");
    const s1 = Array.from(step1.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    const step2 = wrap(s1, reItalic, "em");
    const s2 = Array.from(step2.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    const step3 = wrap(s2, reUline, "u");
    const s3 = Array.from(step3.childNodes).map(n=>n.nodeType===3?n.nodeValue:n.textContent).join("");
    return wrap(s3, reStrike, "s");
  }

  // ---- リゾルバ ----

  function resolveId(ctx, page, path){
    // 優先：階層名（H1>H2>H3）、次に単体名（最下位）
    const dict = ctx.dicts.get(page);
    if(!dict) return null;
    if(path.length){
      const fullKey = path.join(">");
      if(dict.full.has(fullKey)) return dict.full.get(fullKey);
      const leaf = path.at(-1);
      if(dict.single.has(leaf)) return dict.single.get(leaf);
    }
    return null;
  }

  // ---- HTML構築 ----

  function buildHTML(parsed, templateHTML){
    const parser = new DOMParser();
    const doc = parser.parseFromString(templateHTML, "text/html");
    if(!doc || !doc.querySelector) throw new Error("テンプレートの解析に失敗しました。");

    // タイトル / キー埋め込み
    const tplStr = doc.documentElement.outerHTML
      .replaceAll("{{TITLE}}", escapeHtmlText(parsed.title))
      .replaceAll("{{KEY}}", escapeHtmlText(parsed.key));

    const doc2 = parser.parseFromString(tplStr, "text/html");

    // ページごとに構文木化
    const resPerPage = new Map(); // page -> {items, dict, htmlFragment}
    const ctx = { page:null, dicts:new Map() };

    ["info","main","etc"].forEach(page=>{
      const nodes = parsePageLines(parsed.pages[page]||[]);
      const items = buildStructure(nodes);
      assignIds(items);
      const dict = buildHeadingDict(items);
      resPerPage.set(page, {items, dict});
      ctx.dicts.set(page, dict);
    });

    // 一旦 dicts そろったので、段落→HTML生成
    ["info","main","etc"].forEach(page=>{
      const {items} = resPerPage.get(page);
      const sec = doc2.querySelector(`.page[data-page="${page}"]`);
      if(!sec) return;
      sec.innerHTML = ""; // 置換

      const ctxPage = { page, dicts: ctx.dicts };

      // items を順にHTMLへ
      const stack = []; // current parent for appending
      const append = (el) => { (stack.at(-1)||sec).appendChild(el); };

      for(const it of items){
        if(it.type==="h"){
          const tag = it.level===1?"h1":it.level===2?"h2":"h3";
          const h = doc2.createElement(tag);
          h.textContent = it.text;           // 見出しは textContent ベース
          h.id = it.id;
          h.dataset.id = it.id;
          if(it.tags && it.tags.length) h.dataset.tags = it.tags.join(" ");
          sec.appendChild(h);
          // フロー上：見出しは直接 sec に積む（中身の段落は見出しの次兄弟として続く）
        }else if(it.type==="p"){
          const p = doc2.createElement("p");
          // p 内は textContent ベースだが、ジャンプ記法は a で差し込む
          const frag = formatParagraphToNodes(it.text, ctxPage);
          p.appendChild(frag);
          sec.appendChild(p);
        }else if(it.type==="code"){
          const pre = doc2.createElement("pre"); pre.className="code";
          const btn = doc2.createElement("button"); btn.className="copy"; btn.textContent="copy";
          const code = doc2.createElement("code");
          code.textContent = it.code;
          pre.append(btn, code);
          sec.appendChild(pre);
        }else if(it.type==="blank"){
          // 空行は段落間の余白：<p>を作らずスキップ
        }
      }
    });

    // ◆ convert の語を JSON で埋め込み（既存がなければ作成して body 末尾へ）
    const words = parsed.convertWords || [];
    const json  = JSON.stringify({words});
    let node    = doc2.querySelector("#convert-words");
    if(!node){
      node = doc2.createElement("script");
      node.id = "convert-words";
      node.type = "application/json";
      doc2.body.appendChild(node);
    }
    node.textContent = json;

    return "<!doctype html>\n" + doc2.documentElement.outerHTML;
  }

  // ---- Utils ----
  function escapeHtmlText(s){
    return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // ---- I/O: template 読み込み ----
  async function readTemplateFromPicker(){
    if(tplEl.files && tplEl.files[0]){
      return await tplEl.files[0].text();
    }
    // フォールバック：同階層の template.html を試しに取得
    try{
      const res = await fetch("./template.html", {cache:"no-store"});
      if(!res.ok) throw new Error();
      return await res.text();
    }catch{
      throw new Error("テンプレートHTMLが指定されていません（ファイル選択 or 同階層の template.html が必要）。");
    }
  }

  // ---- 変換実行 ----
  btnGen.addEventListener("click", async () => {
    try{
      btnGen.disabled = true;
      clearLog();
      log("▶ 変換開始…");

      const raw = srcEl.value;
      const parsed = parseInput(raw);
      log("✓ 原稿解析:", `title="${parsed.title}" key="${parsed.key}"`);
      log("  - info:", (parsed.pages.info||[]).length, "行");
      log("  - main:", (parsed.pages.main||[]).length, "行");
      log("  - etc :", (parsed.pages.etc ||[]).length, "行");
      log("  - convert 語:", parsed.convertWords.length, "件");

      const tpl = await readTemplateFromPicker();
      log("✓ テンプレート読込 OK");

      const out = buildHTML(parsed, tpl);
      log("✓ HTML構築 OK");

      const fname = sanitizeFileName(parsed.title || "scenario") + ".html";
      downloadText(fname, out);
      log("✓ ダウンロード:", fname);
      log("完了 🎉");
    }catch(err){
      console.error(err);
      alert(err.message || String(err));
      log("✗ エラー:", err.message || String(err));
    }finally{
      btnGen.disabled = false;
    }
  });

  function sanitizeFileName(name){
    return name.replace(/[\\\/:*?"<>|]/g,"_").slice(0,128) || "scenario";
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/html;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
  }

  // ---- サンプル ----
  btnSample.addEventListener("click", ()=>{
    srcEl.value =
`サンプルシナリオ
SAMPLE_KEY
◆ info
# 文字変換
## KPC @重要
### ここはH3
KPC は *探索者* を指す用語です。~~誤記~~ もあります。
'''js
console.log("hello KPC");
'''
# 導入
## あらすじ
HO1 と PC が登場します。#文字変換##KPC にもジャンプできます。

◆ main
# 本編
## 第一章
本文。◆info#導入##あらすじ へジャンプできます。

◆ etc
# 付記
__下線__ と **太字** のテスト。

◆ convert
HO1
PC
KPC`;
    log("✓ サンプル原稿を挿入しました。");
  });

})();
</script>
</body>
</html>