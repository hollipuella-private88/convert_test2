<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TRPGシナリオHTML変換器</title>
<style>
body{font:14px/1.7 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Meiryo",sans-serif;margin:0;padding:16px;background:#fafafa;color:#222}
h1{font-size:20px;margin:0 0 8px}
.wrap{display:grid;grid-template-columns:1fr;gap:12px;max-width:1200px;margin:0 auto}
textarea{width:100%;min-height:38vh;padding:10px;border:1px solid #ddd;border-radius:8px;background:#fff;resize:vertical;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.controls{display:flex;flex-wrap:wrap;gap:8px}
button{border:1px solid #ccc;border-radius:8px;background:#fff;padding:.5em .9em;cursor:pointer}
.out{min-height:38vh}
small.note{color:#666}
</style>
</head>
<body>
<div class="wrap">
  <h1>TRPGシナリオHTML変換器</h1>
  <div class="controls">
    <button id="btnConvert">変換</button>
    <button id="btnDownload">ダウンロード</button>
    <span id="status"><small class="note">同フォルダの <code>template.html</code> を読み込みます。<br>◆ convertは本文に残さず、各行=1語で抽出→<code>id="convert-words"</code> にJSON埋め込み。</small></span>
  </div>
  <textarea id="src" placeholder="1行目=タイトル、2行目=固定キー（[A-Za-z0-9_-]）&#10;◆ convert&#10;HO1&#10;PC&#10;◆ info&#10;# はじめに&#10;本文…"></textarea>
  <textarea id="dst" class="out" placeholder="ここに完成HTMLが出力されます"></textarea>
</div>

<script>
(()=>{"use strict";
/* === util === */
const $=s=>document.querySelector(s);
const src=$("#src"), dst=$("#dst"), btnC=$("#btnConvert"), btnD=$("#btnDownload"), status=$("#status");
const VALID_KEY=/^[A-Za-z0-9_-]+$/;
const keep=s=>s; // 見出し名は記号含め保持
const hashOf=s=>{let h=5381;for(const ch of s){h=((h<<5)+h)+ch.codePointAt(0);h|=0}return(h>>>0).toString(36)};
const uniqueId=(base,taken)=>{let id=base,n=2;while(taken.has(id)) id=base+"-"+(n++); taken.add(id); return id};

/* === インライン装飾（** * __ ~~） === */
function applyInlineMarks(str){
  const root=document.createDocumentFragment(); let i=0;
  const pats=[{re:/\*\*([^*]+)\*\*/y,tag:"strong"},{re:/\*([^*]+)\*/y,tag:"em"},{re:/__([^_]+)__/y,tag:"u"},{re:/~~([^~]+)~~/y,tag:"s"}];
  while(i<str.length){
    let matched=false;
    for(const p of pats){ p.re.lastIndex=i; const m=p.re.exec(str);
      if(m){ if(m.index>i) root.appendChild(document.createTextNode(str.slice(i,m.index)));
        const el=document.createElement(p.tag); el.appendChild(document.createTextNode(m[1])); root.appendChild(el);
        i=p.re.lastIndex; matched=true; break; } }
    if(!matched){ root.appendChild(document.createTextNode(str[i++])); }
  }
  return root;
}

/* === 段落内ジャンプ → <a> === */
function formatParagraph(text, currentPage, dict){
  const frag=document.createDocumentFragment(), N=text.length, isW=ch=>/\s/.test(ch);
  function parseJump(s,i){
    const leftOK=(i===0)||isW(s[i-1]); if(!leftOK) return null;
    let j=i, page=null;
    if(s[j]==="◆"){
      const rest=s.slice(j+1);
      if(rest.startsWith("info#")){ page="info"; j+=1+"info".length; }
      else if(rest.startsWith("main#")){ page="main"; j+=1+"main".length; }
      else if(rest.startsWith("etc#")) { page="etc";  j+=1+"etc".length; }
      else return null;
      if(s[j]!=="#") return null;
    }else if(s[j]!=="#") return null;
    const labels=[]; let pos=j+1;
    const readLabel=p=>{ let q=p; for(;q<N;q++){ if(isW(s[q])) break; if(s[q]==="#"&&(s.slice(q,q+2)==="##"||s.slice(q,q+3)==="###")) break; } return s.slice(p,q); };
    const l1=readLabel(pos); if(!l1) return null; pos+=l1.length; labels.push(l1);
    if(s.slice(pos,pos+2)==="##"){ pos+=2; const l2=readLabel(pos); if(!l2) return null; pos+=l2.length; labels.push(l2); }
    if(s.slice(pos,pos+3)==="###"){ pos+=3; const l3=readLabel(pos); if(!l3) return null; pos+=l3.length; labels.push(l3); }
    const rightOK=(pos>=N)||isW(s[pos]); if(!rightOK) return null;
    return {len:pos-i, page, labels};
  }
  let i=0, buf=""; const flush=()=>{ if(buf){ frag.appendChild(applyInlineMarks(buf)); buf=""; } };
  while(i<N){
    const ch=text[i]; if(ch!=="#"&&ch!=="◆"){ buf+=ch; i++; continue; }
    const hit=parseJump(text,i); if(!hit){ buf+=ch; i++; continue; }
    flush();
    const {page,labels,len}=hit, labs=labels.map(keep), target=page||currentPage, key=labs.join(">"), id=dict[target].get(key)||dict[target].get(labs.at(-1))||null;
    if(id){ const a=document.createElement("a"); a.href=page?("#"+target+":"+id):("#"+id); a.textContent=labs.at(-1); frag.appendChild(a); }
    else{ frag.appendChild(applyInlineMarks(text.slice(i,i+len))); }
    i+=len;
  }
  flush(); return frag;
}

/* === ページマーカー === */
const detectPageMarker=line=>line.replace(/\r/g,"").replace(/[ \t\u3000]+/g," ").trim().match(/^◆\s*(info|main|etc|convert)$/i)?.[1]?.toLowerCase()||null;

/* === 原稿パース（convertは本文を作らず語だけ抽出） === */
function parseInput(raw){
  const lines=raw.replace(/\r\n?/g,"\n").split("\n");
  if(lines.length<2) throw new Error("先頭2行（タイトル/固定キー）が不足しています。");
  const title=lines[0].trim(), key=lines[1].trim();
  if(!title) throw new Error("タイトルが空です。");
  if(!VALID_KEY.test(key)) throw new Error("固定キーが不正です。使用可能文字は [A-Za-z0-9_-] のみ。");

  const pages={info:[], main:[], etc:[]}, heads={info:[], main:[], etc:[]}, stacks={info:[], main:[], etc:[]}, taken={info:new Set(), main:new Set(), etc:new Set()};
  const convertWords=[];
  let cur="main", inCode=false, fence=null, buf=[];

  for(const lineRaw of lines.slice(2)){
    const line=lineRaw; // 原文保持（コード等）
    const pm=!inCode && detectPageMarker(line);
    if(pm){ cur=pm; continue; }

    // convert: 1行=1語（空/空白のみは無視）
    if(cur==="convert"){
      if(!inCode){
        const s=line.trim();
        if(s.length>0) convertWords.push(s);
        continue;
      }
    }

    // 以降は info/main/etc の処理
    const fenceM=line.match(/^(```|''')\s*([A-Za-z0-9#+.\-_]*)\s*$/);
    if(fenceM && !inCode){ inCode=true; fence=fenceM[1]; buf=[]; continue; }
    if(fenceM && inCode && fenceM[1]===fence){ inCode=false; pages[cur].push({type:"node",node:{kind:"code",text:buf.join("\n")}}); continue; }
    if(inCode){ buf.push(line); continue; }

    const mh=line.match(/^(#{1,3})\s+(.+?)\s*$/);
    if(mh){
      const lvl=mh[1].length; let rawTxt=mh[2];
      const tags=[...rawTxt.matchAll(/\s@([^\s@]+)/g)].map(x=>x[1]); rawTxt=rawTxt.replace(/\s@([^\s@]+)/g,"").trim();
      if(tags.includes("メモ")) throw new Error("@メモ は使用禁止です（変換器が自動付与）。");
      while(stacks[cur].length && stacks[cur].at(-1).lvl>=lvl) stacks[cur].pop();
      const trail=stacks[cur].map(n=>n.text), path=[...trail,rawTxt].join(">"), id=uniqueId("h-"+hashOf(path), taken[cur]);
      const node={lvl,text:rawTxt,id,children:[]};
      if(stacks[cur].length) stacks[cur].at(-1).children.push(node); else heads[cur].push(node);
      stacks[cur].push(node);
      pages[cur].push({type:"h",level:lvl,text:rawTxt,id,tags});
      continue;
    }
    pages[cur].push({type:"p",text:line});
  }

  // 見出し辞書（ジャンプ用）
  const dict={info:new Map(), main:new Map(), etc:new Map()};
  for(const pg of ["info","main","etc"]){
    (function walk(nodes, trail=[]){
      for(const n of nodes){
        const k1=n.text, k2=[...trail,n.text].join(">");
        dict[pg].has(k1)||dict[pg].set(k1,n.id); dict[pg].set(k2,n.id);
        n.children?.length && walk(n.children,[...trail,n.text]);
      }
    })(heads[pg],[]);
  }

  return {title, key, pages, dict, convertWords:[...new Set(convertWords)]};
}

/* === template.html に差し込み（convert-words を JSON で埋め込む） === */
async function buildHTML(parsed){
  const tpl=await fetch("template.html").then(r=>{ if(!r.ok) throw new Error("template.html が読み込めませんでした。"); return r.text(); });
  const doc=new DOMParser().parseFromString(tpl,"text/html");

  // タイトル & 固定キー
  doc.title=parsed.title;
  doc.querySelector('meta[name="trpg-key"]')?.setAttribute("content",parsed.key);
  const headTitle=doc.querySelector("header .title"); if(headTitle) headTitle.textContent=parsed.title;

  // 本文差し込み
  const mount=(page, items)=>{
    const sec=doc.querySelector(`section.page[data-page="${page}"]`); if(!sec) return; sec.textContent="";
    for(const it of items){
      if(it.type==="h"){
        const h=doc.createElement(it.level===1?"h1":it.level===2?"h2":"h3");
        h.dataset.id=it.id; if(it.tags.length) h.dataset.tags=it.tags.join(" "); h.appendChild(doc.createTextNode(it.text)); sec.appendChild(h);
      }else if(it.type==="p"){
        const p=doc.createElement("p"); p.appendChild(formatParagraph(it.text,page,parsed.dict)); sec.appendChild(p);
      }else if(it.type==="node" && it.node?.kind==="code"){
        const pre=doc.createElement("pre"); pre.className="code";
        const btn=doc.createElement("button"); btn.className="copy"; btn.textContent="copy";
        const code=doc.createElement("code"); code.appendChild(doc.createTextNode(it.node.text)); pre.append(btn,code); sec.appendChild(pre);
      }
    }
  };
  mount("info",parsed.pages.info); mount("main",parsed.pages.main); mount("etc",parsed.pages.etc);

// ◆ convert → JSON を埋め込み（template 側が読む）
// 既存があれば置換、無ければ新規（重複防止）
const data = JSON.stringify({ words: parsed.convertWords }, null, 0);
let holder = doc.querySelector('#convert-words');
if (holder) {
  holder.textContent = data;
} else {
  holder = doc.createElement('script');
  holder.type = 'application/json';
  holder.id = 'convert-words';
  holder.textContent = data;
  doc.body.appendChild(holder);
}

  return "<!doctype html>\n"+doc.documentElement.outerHTML;
}

/* === UI === */
btnC.onclick=async ()=>{
  try{
    status.textContent="変換中…";
    const parsed=parseInput(src.value||"");
    const html=await buildHTML(parsed);
    dst.value=html;
    status.textContent=`完了 ✔️（convert語: ${parsed.convertWords.length}件）`;
  }catch(err){ status.textContent="エラー ❗ "+(err?.message||err); }
};
btnD.onclick=()=>{
  const blob=new Blob([dst.value||""],{type:"text/html;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="scenario.html"; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
};
})();
</script>
</body>
</html>