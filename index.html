<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TRPGシナリオHTML変換器</title>
<style>
body{font:14px/1.7 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Meiryo",sans-serif;margin:0;padding:16px;background:#fafafa;color:#222}
h1{font-size:20px;margin:0 0 8px}
.wrap{display:grid;grid-template-columns:1fr;gap:12px;max-width:1200px;margin:0 auto}
textarea{width:100%;min-height:38vh;padding:10px;border:1px solid #ddd;border-radius:8px;background:#fff;resize:vertical;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.controls{display:flex;flex-wrap:wrap;gap:8px}
button{border:1px solid #ccc;border-radius:8px;background:#fff;padding:.5em .9em;cursor:pointer}
.out{min-height:38vh}
small.note{color:#666}
pre.sample{white-space:pre-wrap;background:#fff;border:1px dashed #ddd;border-radius:8px;padding:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>TRPGシナリオHTML変換器</h1>
  <div class="controls">
    <button id="btnConvert">変換</button>
    <button id="btnDownload">ダウンロード</button>
    <span id="status"><small class="note">同フォルダの <code>template.html</code> を読み込みます（外部依存なし）。</small></span>
  </div>
  <textarea id="src" placeholder="1行目=タイトル、2行目=固定キー（[A-Za-z0-9_-]）&#10;◆ info&#10;# 【概要（イントロ）】&#10;本文…"></textarea>
  <textarea id="dst" class="out" placeholder="ここに完成HTMLが出力されます"></textarea>
</div>

<script>
(()=>{"use strict";
/* ===== DOM ===== */
const $=s=>document.querySelector(s);
const src=$("#src"), dst=$("#dst"), btnC=$("#btnConvert"), btnD=$("#btnDownload"), status=$("#status");

/* ===== Utils ===== */
// 固定キー
const VALID_KEY=/^[A-Za-z0-9_-]+$/;
// 記号は削らない（見出し文字列に含まれるため）
const keep=(s)=>s;
// 安定ハッシュ（djb2）→ base36
function hashOf(s){ let h=5381; for(const ch of s){ h=((h<<5)+h)+ch.codePointAt(0); h|=0; } return (h>>>0).toString(36); }
function uniqueId(base,taken){ let id=base, n=2; while(taken.has(id)) id=base+"-"+(n++); taken.add(id); return id; }

/* ===== インライン装飾 =====
   文字列 -> DocumentFragment（bold/em/u/s のみ、textContent で安全）
*/
function applyInlineMarks(str){
  const root=document.createDocumentFragment();
  let i=0;
  const pats=[
    {re:/\*\*([^*]+)\*\*/y, tag:"strong"},
    {re:/\*([^*]+)\*/y,     tag:"em"},
    {re:/__([^_]+)__/y,     tag:"u"},
    {re:/~~([^~]+)~~/y,     tag:"s"},
  ];
  while(i<str.length){
    let matched=false;
    for(const p of pats){
      p.re.lastIndex=i;
      const m=p.re.exec(str);
      if(m){
        if(m.index>i) root.appendChild(document.createTextNode(str.slice(i,m.index)));
        const el=document.createElement(p.tag);
        el.appendChild(document.createTextNode(m[1]));
        root.appendChild(el);
        i=p.re.lastIndex; matched=true; break;
      }
    }
    if(!matched){ root.appendChild(document.createTextNode(str[i])); i++; }
  }
  return root;
}

/* ===== 段落内：ハッシュジャンプ → <a> 生成 =====
   - 左境界: 行頭 or 空白
   - 右境界: 空白 or 行末
   - 形: #大##中###小 / ◆(info|main|etc)#大##中###小
   - 見出しテキストは削らない
*/
function formatParagraph(text, currentPage, dict){
  const frag=document.createDocumentFragment();
  const N=text.length;
  const isWhite=ch=>/\s/.test(ch);

  function parseJump(s,i){
    const leftOK=(i===0)||isWhite(s[i-1]);
    if(!leftOK) return null;
    let j=i, page=null;
    if(s[j]==="◆"){
      const rest=s.slice(j+1);
      if(rest.startsWith("info#")){ page="info"; j+=1+"info".length; }
      else if(rest.startsWith("main#")){ page="main"; j+=1+"main".length; }
      else if(rest.startsWith("etc#")) { page="etc";  j+=1+"etc".length; }
      else return null;
      if(s[j]!=="#") return null;
    }else if(s[j]==="#"){
      page=null;
    }else return null;

    const labels=[];
    let k=j; // '#' の位置
    function readLabel(pos){
      let p=pos;
      while(p<N){
        if(isWhite(s[p])) break;
        if(s[p]==="#" && (s.slice(p,p+2)==="##" || s.slice(p,p+3)==="###")) break;
        p++;
      }
      return s.slice(pos,p);
    }
    if(s[k]!=="#") return null;
    let pos=k+1;
    const l1=readLabel(pos); if(!l1) return null;
    pos+=l1.length; labels.push(l1);
    if(s.slice(pos,pos+2)==="##"){ pos+=2; const l2=readLabel(pos); if(!l2) return null; pos+=l2.length; labels.push(l2); }
    if(s.slice(pos,pos+3)==="###"){ pos+=3; const l3=readLabel(pos); if(!l3) return null; pos+=l3.length; labels.push(l3); }

    const rightOK=(pos>=N)||isWhite(s[pos]); if(!rightOK) return null;
    return {len:pos-i, page, labels};
  }

  let i=0, buf="";
  function flushBuf(){ if(buf){ frag.appendChild(applyInlineMarks(buf)); buf=""; } }

  while(i<N){
    const ch=text[i];
    if(ch!=="#" && ch!=="◆"){ buf+=ch; i++; continue; }

    const hit=parseJump(text,i);
    if(!hit){ buf+=ch; i++; continue; }

    // 直前までのテキストを装飾反映
    flushBuf();

    const {page,labels,len}=hit;
    const labs=labels.map(keep);
    const key=labs.join(">");
    const target=page || currentPage;
    const id = dict[target].get(key) || dict[target].get(labs.at(-1)) || null;

    if(id){
      const a=document.createElement("a");
      a.href = page ? ("#"+target+":"+id) : ("#"+id);
      a.textContent = labs.at(-1);  // 最下位の見出しのみ表記
      frag.appendChild(a);
    }else{
      // 見つからなければ原文をそのまま（失敗が見て分かる）
      frag.appendChild(applyInlineMarks(text.slice(i,i+len)));
    }
    i+=len;
  }
  flushBuf();
  return frag;
}

/* ===== プレーンテキスト → 中間構造 ===== */
function parseInput(raw){
  const lines=raw.replace(/\r\n?/g,"\n").split("\n");
  if(lines.length<2) throw new Error("先頭2行（タイトル/固定キー）が不足しています。");
  const title=lines[0].trim();
  const key=lines[1].trim();
  if(!title) throw new Error("タイトルが空です。");
  if(!VALID_KEY.test(key)) throw new Error("固定キーが不正です。使用可能文字は [A-Za-z0-9_-] のみ。");

  const pages={info:[], main:[], etc:[]};
  const headsTree={info:[], main:[], etc:[]};
  const stacks={info:[], main:[], etc:[]};
  const taken={info:new Set(), main:new Set(), etc:new Set()};
  let cur="main";

  let inCode=false, codeFence=null, codeBuf=[];

  const body=lines.slice(2);
  for(let i=0;i<body.length;i++){
    const line=body[i];

    // ページ切替
    const mPage=line.match(/^◆\s*([^\s]+)\s*$/);
    if(!inCode && mPage){
      const nm=mPage[1];
      if(nm==="info"||nm==="main"||nm==="etc"){ cur=nm; continue; }
      // それ以外は段落扱いに落とす
    }

    // コードフェンス
    const mFence=line.match(/^(```|''')\s*([A-Za-z0-9#+.\-_]*)\s*$/);
    if(mFence && !inCode){ inCode=true; codeFence=mFence[1]; codeBuf=[]; continue; }
    if(mFence && inCode && mFence[1]===codeFence){
      inCode=false;
      pages[cur].push({type:"node", node:{kind:"code", text:codeBuf.join("\n")}});
      continue;
    }
    if(inCode){ codeBuf.push(line); continue; }

    // 見出し (# + 空白)
    const mH=line.match(/^(#{1,3})\s+(.+?)\s*$/);
    if(mH){
      const level=mH[1].length;
      let raw=mH[2];

      const tagMatches=[...raw.matchAll(/\s@([^\s@]+)/g)].map(x=>x[1]);
      raw = raw.replace(/\s@([^\s@]+)/g,"").trim();
      const tags=[];
      for(const t of tagMatches){
        const name=t.trim();
        if(!name) continue;
        if(name==="メモ") throw new Error("@メモ は使用禁止です（変換器が自動付与）。");
        tags.push(name);
      }

      while(stacks[cur].length && stacks[cur].at(-1).lvl>=level) stacks[cur].pop();
      const parentTrail=stacks[cur].map(n=>n.text);
      const path=[...parentTrail, raw].join(">");    // ← 階層パスをそのまま
      const id=uniqueId("h-"+hashOf(path), taken[cur]);

      const node={lvl:level, text:raw, id, children:[]};
      if(stacks[cur].length) stacks[cur].at(-1).children.push(node); else headsTree[cur].push(node);
      stacks[cur].push(node);

      pages[cur].push({type:"h", level, text:raw, id, tags});
      continue;
    }

    // 段落
    pages[cur].push({type:"p", text:line});
  }

  // 見出し辞書（ページ別）
  const dict={info:new Map(), main:new Map(), etc:new Map()};
  for(const pg of ["info","main","etc"]){
    (function walk(nodes, trail=[]){
      for(const n of nodes){
        const k1=n.text, k2=[...trail,n.text].join(">");
        if(!dict[pg].has(k1)) dict[pg].set(k1, n.id);
        dict[pg].set(k2, n.id);
        if(n.children?.length) walk(n.children, [...trail,n.text]);
      }
    })(headsTree[pg], []);
  }

  return {title:key?title:title, key, pages, dict};
}

/* ===== template.html に差し込み ===== */
async function buildHTML(parsed){
  const tplText=await fetch("template.html").then(r=>{ if(!r.ok) throw new Error("template.html が読み込めませんでした。"); return r.text(); });
  const doc=new DOMParser().parseFromString(tplText,"text/html");

  // タイトル／固定キー
  doc.title=parsed.title;
  const metaKey=doc.querySelector('meta[name="trpg-key"]'); if(metaKey) metaKey.setAttribute("content", parsed.key);
  const headerTitle=doc.querySelector("header .title"); if(headerTitle) headerTitle.textContent=parsed.title;

  // ページ描画
  function mountPage(pageName, items){
    const sec=doc.querySelector(`section.page[data-page="${pageName}"]`);
    if(!sec) return;
    while(sec.firstChild) sec.removeChild(sec.firstChild);

    for(const it of items){
      if(it.type==="h"){
        const tag = it.level===1?"h1":it.level===2?"h2":"h3";
        const h=doc.createElement(tag);
        h.dataset.id=it.id;
        if(it.tags.length) h.dataset.tags=it.tags.join(" ");
        h.appendChild(document.createTextNode(it.text));
        sec.appendChild(h);
      }else if(it.type==="p"){
        const p=doc.createElement("p");
        p.appendChild(formatParagraph(it.text, pageName, parsed.dict)); // ← 段落時にジャンプ変換まで完了
        sec.appendChild(p);
      }else if(it.type==="node" && it.node?.kind==="code"){
        const pre=doc.createElement("pre"); pre.className="code";
        const btn=doc.createElement("button"); btn.className="copy"; btn.textContent="copy";
        const code=doc.createElement("code"); code.appendChild(document.createTextNode(it.node.text));
        pre.append(btn,code); sec.appendChild(pre);
      }
    }
  }

  mountPage("info", parsed.pages.info);
  mountPage("main", parsed.pages.main);
  mountPage("etc",  parsed.pages.etc);

  // 完成HTML
  return "<!doctype html>\n"+doc.documentElement.outerHTML;
}

/* ===== 操作系 ===== */
btnConvert.onclick = btnC.onclick = async ()=>{
  try{
    status.textContent="変換中…";
    const parsed=parseInput(src.value||"");
    const html=await buildHTML(parsed);
    dst.value=html;
    status.textContent="完了 ✔️";
  }catch(err){
    status.textContent="エラー ❗ "+(err?.message||err);
  }
};
btnDownload.onclick = btnD.onclick = ()=>{
  const blob=new Blob([dst.value||""],{type:"text/html;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="scenario.html"; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
};
})();
</script>
</body>
</html>