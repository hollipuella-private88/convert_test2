<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TRPGシナリオHTML変換器</title>
<style>
body{font:14px/1.7 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Meiryo",sans-serif;margin:0;padding:16px;background:#fafafa;color:#222}
h1{font-size:20px;margin:0 0 8px}
.wrap{display:grid;grid-template-columns:1fr;gap:12px;max-width:1200px;margin:0 auto}
textarea{width:100%;min-height:38vh;padding:10px;border:1px solid #ddd;border-radius:8px;background:#fff;resize:vertical;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.controls{display:flex;flex-wrap:wrap;gap:8px}
button{border:1px solid #ccc;border-radius:8px;background:#fff;padding:.5em .9em;cursor:pointer}
.out{min-height:38vh}
small.note{color:#666}
</style>
</head>
<body>
<div class="wrap">
  <h1>TRPGシナリオHTML変換器</h1>
  <div class="controls">
    <button id="btnConvert">変換</button>
    <button id="btnDownload">ダウンロード</button>
    <span id="status"><small class="note">同じフォルダの <code>template.html</code> を読み込みます。</small></span>
  </div>
  <textarea id="src" placeholder="1行目=タイトル、2行目=固定キー（[A-Za-z0-9_-]）&#10;◆ main&#10;# 導入 @タグA&#10;本文…"></textarea>
  <textarea id="dst" class="out" placeholder="ここに完成HTMLが出力されます"></textarea>
</div>

<script>
(()=>{"use strict";
const $=s=>document.querySelector(s);
const src=$("#src"), dst=$("#dst"), btnC=$("#btnConvert"), btnD=$("#btnDownload"), status=$("#status");

const VALID_KEY=/^[A-Za-z0-9_-]+$/;
// 文末句読点のみ除去（括弧は残す）
const trimPunct=(s)=>s.replace(/[。、．，,、。…!！?？]+$/u,"");

// 見出し照合用の正規化
function normKey(s){
  if(!s) return "";
  let out=s.normalize("NFKC");
  // 不可視類
  out=out.replace(/[\u200B-\u200D\uFEFF\u180E\u00AD\u2060\uFE00-\uFE0F]/g,"");
  // 空白ゆらぎ
  out=out.replace(/\u3000/g," ").replace(/\s+/g," ").trim();
  // よくある記号ゆらぎ
  out=out.replace(/[\u2010-\u2015\u2212\u30FC\uFF0D]/g,"-"); // 長音/ハイフン
  out=out.replace(/[\uFF1A\u2236]/g,":");                  // コロン
  out=out.replace(/[\u00B7\u2219\u2027]/g,"・");            // 中黒
  out=out.replace(/[\u201C\u201F]/g,"“").replace(/[\u201D]/g,"”");
  return out;
}
// 安定ID
function hashOf(s){let h=5381;for(const ch of s){h=((h<<5)+h)+ch.codePointAt(0);h|=0;}return(h>>>0).toString(36);}
function uniqueId(base,taken){let id=base,n=2;while(taken.has(id))id=base+"-"+(n++);taken.add(id);return id;}
// 安全ノード
function makeEl(name,attrs={},children=[]){const el=document.createElement(name);for(const[k,v]of Object.entries(attrs||{})){if(k==="text"){el.textContent=v;}else if(k==="dataset"){for(const[dk,dv]of Object.entries(v))el.dataset[dk]=dv;}else if(k==="className"){el.className=v;}else{el.setAttribute(k,v);}}for(const ch of children)el.appendChild(ch);return el;}

// インライン装飾（text→nodes）
function formatInline(text){
  const root=document.createDocumentFragment();let i=0;
  const pats=[
    {re:/\*\*([^*]+)\*\*/y,wrap:(t)=>["strong",t]},
    {re:/\*([^*]+)\*/y,wrap:(t)=>["em",t]},
    {re:/__([^_]+)__/y,wrap:(t)=>["u",t]},
    {re:/~~([^~]+)~~/y,wrap:(t)=>["s",t]},
  ];
  while(i<text.length){
    let hit=false;
    for(const p of pats){
      p.re.lastIndex=i;
      const m=p.re.exec(text);
      if(m){
        if(m.index>i) root.appendChild(document.createTextNode(text.slice(i,m.index)));
        const[tag,content]=p.wrap(m[1]); const el=document.createElement(tag);
        el.appendChild(document.createTextNode(content)); root.appendChild(el);
        i=p.re.lastIndex; hit=true; break;
      }
    }
    if(!hit){ root.appendChild(document.createTextNode(text[i])); i++; }
  }
  return root;
}

// 入力パース
function parseInput(raw){
  const lines=raw.replace(/\r\n?/g,"\n").split("\n");
  if(lines.length<2) throw new Error("先頭2行（タイトル/固定キー）が不足しています。");
  const title=lines[0].trim(); const key=lines[1].trim();
  if(!title) throw new Error("タイトルが空です。");
  if(!VALID_KEY.test(key)) throw new Error("固定キーが不正です。");

  const pages={info:[],main:[],etc:[]};
  const headsTree={info:[],main:[],etc:[]};
  const stacks={info:[],main:[],etc:[]};
  const taken={info:new Set(),main:new Set(),etc:new Set()};
  let cur="main";

  let inCode=false, fence=null, codeBuf=[];
  for(const lineRaw of lines.slice(2)){
    const line=lineRaw;
    // ◆ページ
    const mPage=line.match(/^◆\s*([^\s]+)\s*$/);
    if(!inCode && mPage){
      const name=mPage[1];
      if(name==="info"||name==="main"||name==="etc"){cur=name; continue;}
    }
    // ```/'''
    const mFence=line.match(/^(```|''')\s*([A-Za-z0-9#+.-_]*)\s*$/);
    if(mFence && !inCode){ inCode=true; fence=mFence[1]; codeBuf=[]; continue; }
    if(mFence && inCode && mFence[1]===fence){
      inCode=false;
      const pre=makeEl("pre",{className:"code"},[
        makeEl("button",{className:"copy",text:"copy"}),
        makeEl("code",{},[document.createTextNode(codeBuf.join("\n"))])
      ]);
      pages[cur].push({type:"node",node:pre});
      continue;
    }
    if(inCode){ codeBuf.push(line); continue; }

    // 見出し（# + 半角スペース必須）
    const mH=line.match(/^(#{1,3})\s+(.+?)\s*$/);
    if(mH){
      const level=mH[1].length; let raw=mH[2];
      const tags=[];
      raw=raw.replace(/\s@([^\s@]+)/g,(m,t)=>{ if(t==="メモ") throw new Error("@メモは禁止"); tags.push(t); return ""; }).trim();
      while(stacks[cur].length && stacks[cur].at(-1).lvl>=level) stacks[cur].pop();
      const parents=stacks[cur].map(n=>n.text);
      const path=[...parents,raw].join(">");
      const id=uniqueId("h-"+hashOf(path), taken[cur]);
      const node={lvl:level,text:raw,id,children:[]};
      if(stacks[cur].length) stacks[cur].at(-1).children.push(node); else headsTree[cur].push(node);
      stacks[cur].push(node);
      pages[cur].push({type:"h",level,text:raw,id,tags});
      continue;
    }

    // 段落
    pages[cur].push({type:"p",text:line});
  }

  // 経路辞書（raw & 正規化）
  const dict={info:new Map(),main:new Map(),etc:new Map()};
  for(const pg of ["info","main","etc"]){
    (function walk(nodes, trail=[]){
      for(const n of nodes){
        const raw1=n.text;
        const raw2=[...trail,n.text].join(">");
        const k1=normKey(raw1), k2=normKey(raw2);
        if(!dict[pg].has(raw1)) dict[pg].set(raw1, n.id);
        if(!dict[pg].has(k1))   dict[pg].set(k1,   n.id);
        dict[pg].set(raw2, n.id);
        dict[pg].set(k2,   n.id);
        if(n.children?.length) walk(n.children,[...trail,n.text]);
      }
    })(headsTree[pg],[]);
  }
  return {title,key,pages,dict,headsTree};
}

// HTML構築
async function buildHTML(parsed){
  const tpl=await fetch("template.html").then(r=>{if(!r.ok) throw new Error("template.html を読み込めません"); return r.text();});
  const doc=new DOMParser().parseFromString(tpl,"text/html");
  doc.title=parsed.title;
  const mk=doc.querySelector('meta[name="trpg-key"]'); if(mk) mk.setAttribute("content", parsed.key);
  const ht=doc.querySelector("header .title"); if(ht) ht.textContent=parsed.title;

  function mountPage(name,items){
    const sec=doc.querySelector(`section.page[data-page="${name}"]`); if(!sec) return;
    while(sec.firstChild) sec.removeChild(sec.firstChild);
    for(const it of items){
      if(it.type==="h"){
        const tag=it.level===1?"h1":it.level===2?"h2":"h3";
        const h=doc.createElement(tag);
        h.dataset.id=it.id; if(it.tags?.length) h.dataset.tags=it.tags.join(" ");
        h.appendChild(document.createTextNode(it.text));
        sec.appendChild(h);
      }else if(it.type==="p"){
        const p=doc.createElement("p"); p.appendChild(formatInline(it.text)); sec.appendChild(p);
      }else if(it.type==="node"){
        sec.appendChild(it.node.cloneNode(true));
      }
    }
  }
  mountPage("info",parsed.pages.info);
  mountPage("main",parsed.pages.main);
  mountPage("etc", parsed.pages.etc);

  // ハッシュジャンプ（空白＆日本語句読点で終端判定／ラベル内空白OK）
  function wireJumps(){
    const dict=parsed.dict;
    const END_BOUND=/[\s、。．，,）\)\]】」』＞>」』】〉》]+|$/u; // 空白 or 主要句読点・閉じカッコ類 or 行末
    const walker=doc.createTreeWalker(doc.body,NodeFilter.SHOW_TEXT,{
      acceptNode(n){
        if(!n.nodeValue || !n.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        const p=n.parentElement; if(!p) return NodeFilter.FILTER_REJECT;
        if(p.closest("h1,h2,h3,pre,code,.code")) return NodeFilter.FILTER_REJECT;
        return NodeFilter.FILTER_ACCEPT;
      }
    });

    while(walker.nextNode()){
      const node=walker.currentNode;
      const txt=node.nodeValue;
      // （空白|行頭）◆page? #...（空白/句読点/閉じカッコ/行末）
      const RE=/(\s|^)(?:◆(info|main|etc))?\s*(#)(?=[^\s])?/gu;
      let m, last=0, parts=[], touched=false;

      while((m=RE.exec(txt))){
        const left=m[1], page=m[2]||null;
        let start=RE.lastIndex; // '#' の直後
        if(txt[start-1] !== "#") continue; // 念のため

        // チャンク終端を探す（次の END_BOUND まで）
        END_BOUND.lastIndex=start;
        const endMatch=END_BOUND.exec(txt);
        const end = endMatch ? endMatch.index : txt.length;
        const chunk = txt.slice(start-1, end); // 先頭の '#' を含む

        const labelsRaw=parseChain(chunk);
        if(!labelsRaw){ continue; }

        // 照合キー
        const labelsNor=labelsRaw.map(normKey);
        const queryRaw=labelsRaw.map(trimPunct).join(">");
        const queryNor=labelsNor.map(trimPunct).join(">");
        const pool=page||findPageOfNode(node);
        const d = page ? dict[page] : dict[pool];
        let id = d.get(queryRaw) || d.get(trimPunct(labelsRaw.at(-1))) ||
                 d.get(queryNor) || d.get(trimPunct(labelsNor.at(-1))) || null;

        touched=true;
        parts.push(document.createTextNode(txt.slice(last, m.index + left.length)));
        if(id){
          const aEl=doc.createElement("a");
          aEl.setAttribute("href", page? ("#"+page+":"+id) : ("#"+id));
          // 見えるテキストも即時に入れておく（テンプレ側の補完がなくてもOK）
          aEl.textContent=labelsRaw.join(" / ");
          parts.push(aEl);
        }else{
          parts.push(document.createTextNode(chunk)); // 解決不可は原文維持
        }
        last=end;
        RE.lastIndex=end; // スキャン位置を進める
      }

      if(touched){
        parts.push(document.createTextNode(txt.slice(last)));
        const frag=document.createDocumentFragment(); parts.forEach(p=>frag.appendChild(p));
        node.parentNode.replaceChild(frag,node);
      }
    }

    function findPageOfNode(n){
      const sec=n.parentElement?.closest("section.page");
      return sec?.dataset.page||"main";
    }

    // '#大##中###小' を段階分割（内部の空白は許容）
    function parseChain(chunk){
      if(!chunk || chunk[0]!=="#") return null;
      let i=1; const labels=[];
      for(let k=0;k<3;k++){
        const next=findNextDelim(chunk,i);
        if(next===-1){
          const raw=chunk.slice(i).trim(); if(!raw) break;
          labels.push(raw); break;
        }else{
          const raw=chunk.slice(i,next).trim(); if(!raw) return null;
          labels.push(raw);
          const isTriple = chunk.startsWith("###",next);
          i=next+(isTriple?3:2);
        }
      }
      return labels.length?labels:null;
    }
    function findNextDelim(s,from){
      // 次の '##' を見つける（'###' もここで拾える）
      let i=s.indexOf("##",from);
      return i===-1? -1 : i;
    }
  }
  wireJumps();

  return "<!doctype html>\n"+doc.documentElement.outerHTML;
}

// 実行
btnC.onclick=async()=>{
  try{
    status.textContent="変換中…";
    const parsed=parseInput(src.value||"");
    const html=await buildHTML(parsed);
    dst.value=html;
    status.textContent="完了 ✔️";
  }catch(err){
    status.textContent="エラー ❗ "+(err?.message||err);
  }
};
btnD.onclick=()=>{
  const blob=new Blob([dst.value||""],{type:"text/html;charset=utf-8"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="scenario.html";
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
};
})();
</script>
</body>
</html>